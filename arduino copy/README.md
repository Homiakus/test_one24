# Система управления 5 шаговыми двигателями с GyverPlanner

Программа для Arduino Mega 2560 с использованием библиотеки **GyverPlanner** для управления 5 шаговыми двигателями с высокоскоростным координированным движением, упрощенным хомингом и Serial интерфейсом.

## Возможности

- **GyverPlanner координированное движение** - синхронное высокоскоростное перемещение всех 5 двигателей
- **Упрощенный хоминг** - алгоритм поиска нуля по образцу из документации GyverPlanner
- **Индивидуальный и координированный хоминг** - отдельные моторы или E0+E1 вместе
- **Serial команды** - полное управление через последовательный порт
- **Поддержка NPN и PNP датчиков** - автоматическое определение типа концевых выключателей
- **Управление дополнительными пинами** - 10 управляющих выходов
- **Совместимость с аналоговыми пинами** - поддержка A0, A6, A7 как step/dir пинов
- **Высокоскоростные E0/E1** - до 30000 шагов/сек для быстрых операций
- **Умное управление питанием** - моторы с постоянным или временным питанием

## Технические характеристики

- **Платформа**: Arduino Mega 2560
- **Основная библиотека**: GyverPlanner (упрощенный API)
- **Максимальная скорость**: 30000 шагов/сек (E0/E1)
- **Бод**: 115200
- **Особенность**: Правильное использование GyverPlanner API с упрощенной логикой

## Конфигурация двигателей

### Таблица конфигурации
| Двигатель      | Step Pin | Dir Pin | Enable Pin | Home Pin | Тип датчика | Макс.скорость | Питание    |
|----------------|----------|---------|------------|----------|-------------|---------------|------------|
| Multi (X)      | A0       | A1      | 38         | 14       | **PNP**     | 10000 шаг/сек | Постоянное |
| Multizone (Y)  | A6       | A7      | A2         | 2        | **NPN**     | 200 шаг/сек   | Постоянное |
| RRight (Z)     | 46       | 48      | A8         | 2        | **NPN**     | 1000 шаг/сек  | Постоянное |
| E0             | 26       | 28      | 24         | 15       | **PNP**     | 30000 шаг/сек | Временное  |
| E1             | 36       | 34      | 30         | 15       | **PNP**     | 30000 шаг/сек | Временное  |

### Особенности конфигурации
- **Постоянное питание** - моторы Multi, Multizone, RRight всегда включены для точности
- **Временное питание** - моторы E0, E1 включаются только для движения (экономия энергии)
- **Общий датчик E0+E1** - оба мотора используют датчик на пине 15
- **Высокие скорости E0/E1** - настроены на 30000 шагов/сек для быстрых операций

### Дополнительные управляющие пины
| Индекс | Пин | Назначение |
|--------|-----|------------|
| 0      | 18  | PUMP       |
| 1      | 8   | KL1        |
| 2      | 10  | KL2        |
| 3      | 19  | WASTE      |
| 4      | 27  | ROTOR1     |
| 5      | 29  | ROTOR2     |
| 6      | 23  | ROTOR3     |
| 7      | 25  | ROTOR4     |
| 8      | 42  | HX711_SCK  |
| 9      | 40  | HX711_DT   |

## Команды

### `sm pos0 pos1 pos2 pos3 pos4` - Координированное движение
Перемещает двигатели на указанные позиции (в пользовательских единицах).  
Используйте `*` для пропуска двигателя.

**Примеры:**
```
sm 10 20 * 5 15        // Multi=10, Multizone=20, RRight=*, E0=5, E1=15
sm 0 0 0 0 0           // Все двигатели в нулевую позицию  
sm * * 50 * *          // Только RRight (Z) на 50 единиц
sm 100 * * 1000 1000   // Multi=100, E0=1000, E1=1000 (быстрое движение)
```

### `sh bool0 bool1 bool2 bool3 0` - Индивидуальный хоминг
Выполняет поиск нуля для выбранных двигателей (только индексы 0-3).  
**Важно**: E1 (индекс 4) не поддерживается, используйте `clamph` для E0+E1.

**Примеры:**
```
sh 1 1 1 1 0           // Хоминг Multi, Multizone, RRight, E0 индивидуально
sh 1 0 0 0 0           // Только Multi
sh 0 0 0 1 0           // Только E0 (E1 нужно хомить через clamph)
```

### `clamph` - Координированный хоминг E0+E1
Выполняет координированный поиск нуля для E0 и E1 одновременно с использованием общего датчика.

**Примеры:**
```
clamph                 // Координированный хоминг E0+E1 через общий датчик
```

### `pon index` / `poff index` - Управление пинами
Включает/отключает дополнительный управляющий пин.

**Примеры:**
```
pon 0                  // Включить насос (пин 18)
poff 0                 // Отключить насос
pon 1                  // Включить клапан KL1 (пин 8)
pon 4                  // Включить ROTOR1 (пин 27)
```

### `status` - Состояние системы
Показывает полную информацию о системе: позиции, датчики, конфигурацию пинов, состояние планировщика.

### `test` - Комплексный тест
Тестирует все моторы прямым управлением пинами в течение 10 секунд.

## Алгоритм хоминга (упрощенный)

### Индивидуальный хоминг (`sh` команда)
Для каждого выбранного мотора (Multi, Multizone, RRight, E0):

1. **Если датчик сработал** - отъезжаем: `setSpeed()` → `while + tick()` → `brake()`
2. **Движемся к датчику** - `setSpeed()` → `while + tick()` → `brake()`
3. **Сброс позиции** - `planner.reset()` устанавливает все позиции в 0

### Координированный хоминг E0+E1 (`clamph` команда)
1. **Если общий датчик сработал** - оба мотора отъезжают координированно
2. **Движемся к датчику** - оба мотора движутся синхронно
3. **Сброс позиций** - E0 и E1 устанавливаются в 0

### Поддержка NPN и PNP датчиков
- **NPN датчики** (Multizone, RRight): Активное состояние = LOW (заземление)
- **PNP датчики** (Multi, E0, E1): Активное состояние = HIGH (питание)

## Установка

1. Установите PlatformIO
2. Склонируйте репозиторий:
   ```bash
   git clone <repository-url>
   cd arduino-stepper-system
   ```
3. Скомпилируйте и загрузите:
   ```bash
   pio run --target upload
   ```

## Архитектура системы

### GyverPlanner интеграция
```cpp
// Создание шаговиков
Stepper<STEPPER2WIRE> stepper0(A0, A1);  // Multi
Stepper<STEPPER2WIRE> stepper1(A6, A7);  // Multizone
// ... остальные

// Планировщик для 5 осей
GPlanner<STEPPER2WIRE, 5> planner;

// Добавление в планировщик
planner.addStepper(0, stepper0);
planner.addStepper(1, stepper1);
// ... остальные
```

### Основные функции
- `moveMotorsToPosition()` - координированное движение через `setTarget()`
- `stepperHome()` - индивидуальный хоминг через `setSpeed()`
- `clampHome()` - координированный хоминг E0+E1 через `setSpeed()`

## Диагностика

### Команда `status` - полная информация
```
=== GYVER PLANNER SYSTEM STATUS ===
Motors enabled: YES/NO
Homing active: YES/NO  
Planner ready: READY/BUSY

Motor positions:
Multi(X): 0.00 units (0 steps)
Multizone(Y): 0.00 units (0 steps)
RRight(Z): 0.00 units (0 steps)  
E0: 0.00 units (0 steps)
E1: 0.00 units (0 steps)

Home switches:
Multi(X) (PNP): TRIGGERED/OPEN
Multizone(Y) (NPN): TRIGGERED/OPEN
RRight(Z) (NPN): TRIGGERED/OPEN
E0 (PNP): TRIGGERED/OPEN
E1 (PNP): TRIGGERED/OPEN

Motor power settings:
Multi(X) - Power mode: ALWAYS ON, Current state: ENABLED
Multizone(Y) - Power mode: ALWAYS ON, Current state: ENABLED  
RRight(Z) - Power mode: ALWAYS ON, Current state: ENABLED
E0 - Power mode: TEMPORARY, Current state: DISABLED
E1 - Power mode: TEMPORARY, Current state: DISABLED
```

### Частые проблемы

1. **Планировщик всегда занят**: Исправлено заменой `planner.stop()` на `planner.reset()`
2. **Неправильный тип датчика**: Проверьте конфигурацию NPN/PNP в коде
3. **E1 не хомится через sh**: Используйте `clamph` для координированного хоминга E0+E1
4. **Низкая скорость**: E0/E1 настроены на 30000 шагов/сек для высокой производительности

## Особенности реализации

### Упрощенная логика (по образцу GyverPlanner)
```cpp
// Пример хоминга
planner.setSpeed(motor, -speed);        // Устанавливаем скорость  
while (!readHomeSwitch(motor)) {        // Пока датчик не сработал
    planner.tick();                     // Выполняем шаг планировщика
}
planner.brake();                        // Останавливаемся
```

### Правильная очистка планировщика
```cpp
// ПРАВИЛЬНО - полная очистка
planner.reset();  

// НЕПРАВИЛЬНО - оставляет планировщик занятым  
planner.stop();   
```

### Enum-ы для типизации
```cpp
enum MotorType {
    MOTOR_MULTI = 0,      // Multi(X)
    MOTOR_MULTIZONE = 1,  // Multizone(Y) 
    MOTOR_RRIGHT = 2,     // RRight(Z)
    MOTOR_E0 = 3,         // E0
    MOTOR_E1 = 4          // E1
};
```

## Возвращаемые статусы

Все команды возвращают:
- **`COMPLETE`** - команда выполнена успешно
- **`ERROR`** - произошла ошибка (с описанием)

Это позволяет внешним системам отслеживать состояние выполнения команд.

## Разработка

Система спроектирована с учетом принципов:
- **SOLID** - разделение ответственности
- **KISS** - простота и понятность
- **DRY** - отсутствие дублирования кода

Вся документация ведется в папке `/docs/`:
- `changelog.md` - история изменений
- `tasktracker.md` - статус задач
- `project.md` - архитектурная документация 