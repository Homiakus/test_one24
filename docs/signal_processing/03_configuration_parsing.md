# Система обработки входящих сигналов UART - Этап 3: Конфигурация и парсинг

## Обзор
Этап 3 включает в себя расширение системы конфигурации для поддержки секции `signals`, создание специализированного парсера и добавление валидации конфигурации сигналов.

## Реализованные компоненты

### 1. Расширение ConfigLoader

#### 1.1 Поддержка секции signals
- Добавлена секция `signals` в `DEFAULT_CONFIG`
- Расширена валидация структуры конфигурации
- Добавлены методы для работы с сигналами

#### 1.2 Новые методы ConfigLoader
```python
def load_signals(self) -> Dict[str, str]:
    """Загрузка конфигурации сигналов"""
    
def get_signal_mappings(self) -> Dict[str, 'SignalMapping']:
    """Получение маппингов сигналов в структурированном виде"""
```

#### 1.3 Валидация секции signals
- Проверка формата маппингов: `"сигнал" = "переменная (тип)"`
- Валидация имен сигналов (только заглавные буквы, цифры, подчеркивания)
- Проверка уникальности имен сигналов и переменных
- Автоматическое создание обязательных сигналов при их отсутствии

### 2. SignalConfigParser

#### 2.1 Основные возможности
- Парсинг файлов конфигурации TOML
- Извлечение секции `signals`
- Валидация конфигурации сигналов
- Сохранение конфигурации в файл

#### 2.2 Ключевые методы
```python
def parse_config_file(self, config_path: Path) -> Dict[str, SignalMapping]:
    """Парсинг файла конфигурации и извлечение секции signals"""
    
def validate_signal_config(self, signals: Dict[str, SignalMapping]) -> List[str]:
    """Валидация конфигурации сигналов"""
    
def save_signals_config(self, config_path: Path, signals: Dict[str, SignalMapping]) -> bool:
    """Сохранение конфигурации сигналов в файл"""
```

#### 2.3 Парсинг строк сигналов
- Поддержка формата: `"SIGNAL" = "variable (type)"`
- Обработка комментариев и пустых строк
- Валидация имен сигналов и маппингов
- Обработка ошибок парсинга

### 3. Формат конфигурации

#### 3.1 Структура секции signals
```toml
[signals]
# Сигналы UART для автоматического обновления переменных
# Формат: "сигнал" = "переменная (тип)"

# Температура
"TEMP" = "temperature (float)"

# Статус устройства
"STATUS" = "device_status (string)"

# Код ошибки
"ERROR" = "error_code (int)"

# Давление
"PRESSURE" = "pressure (float)"

# Режим работы
"MODE" = "operation_mode (string)"
```

#### 3.2 Поддерживаемые типы данных
- `float` - числа с плавающей точкой
- `int` - целые числа
- `string` - строки
- `bool` - логические значения
- `json` - JSON объекты

#### 3.3 Правила именования
- **Сигналы**: только заглавные буквы, цифры, подчеркивания (максимум 50 символов)
- **Переменные**: начинаются с буквы или подчеркивания, содержат буквы, цифры, подчеркивания

### 4. Валидация конфигурации

#### 4.1 Проверки валидации
- Уникальность имен сигналов
- Уникальность имен переменных
- Валидность имен сигналов
- Валидность имен переменных
- Поддержка типов данных

#### 4.2 Обработка ошибок
- Логирование предупреждений для некорректных записей
- Автоматическое удаление невалидных сигналов
- Создание обязательных сигналов по умолчанию

### 5. Интеграция с существующей системой

#### 5.1 Совместимость
- Полная совместимость с существующим `ConfigLoader`
- Сохранение всех существующих секций конфигурации
- Обратная совместимость с файлами без секции `signals`

#### 5.2 Автоматическое создание
- Создание секции `signals` при отсутствии
- Добавление обязательных сигналов по умолчанию
- Валидация при загрузке конфигурации

## Тестирование

### Unit тесты
Созданы comprehensive unit тесты для `SignalConfigParser`:
- Парсинг файлов конфигурации
- Валидация сигналов
- Обработка ошибок
- Сохранение конфигурации

### Тестовые сценарии
- Успешный парсинг валидной конфигурации
- Обработка файлов без секции signals
- Валидация некорректных данных
- Замена существующей секции signals

## Использование

### 1. Загрузка конфигурации сигналов
```python
from config.config_loader import ConfigLoader

config_loader = ConfigLoader()
config = config_loader.load()
signal_mappings = config_loader.get_signal_mappings()
```

### 2. Парсинг файла конфигурации
```python
from config.signal_config_parser import SignalConfigParser

parser = SignalConfigParser()
signals = parser.parse_config_file(Path("config.toml"))
```

### 3. Валидация конфигурации
```python
errors = parser.validate_signal_config(signals)
if errors:
    print("Ошибки валидации:", errors)
```

### 4. Сохранение конфигурации
```python
success = parser.save_signals_config(Path("config.toml"), signals)
```

## Следующие этапы

### Этап 4: Интеграция с UART системой
- Расширение `SerialManager` для обработки входящих данных
- Интеграция `SignalManager` с системой UART
- Обработка входящих сигналов в реальном времени

### Этап 5: UI компоненты
- Создание интерфейса для настройки сигналов
- Отображение текущих значений сигналов
- Управление конфигурацией сигналов

### Этап 6: Тестирование и оптимизация
- Интеграционные тесты
- Тестирование производительности
- Оптимизация обработки сигналов

## Заключение

Этап 3 успешно завершен. Реализована полная поддержка конфигурации сигналов с:
- Расширенным `ConfigLoader`
- Специализированным `SignalConfigParser`
- Комплексной валидацией
- Unit тестами
- Документацией

Система готова к интеграции с UART для обработки входящих сигналов в реальном времени.
