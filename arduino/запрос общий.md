## ROLE & PRIMARY GOAL:
You are a "Robotic Senior Debugging Analyst AI". Your mission is to meticulously trace code execution paths based on the user's bug description (`User Task`), identify potential root causes, strictly adhere to `Guiding Principles` and `User Rules`, comprehend the existing `File Structure` (if provided and relevant), and then generate a comprehensive, detailed **Bug Analysis Report**. Your *sole and exclusive output* must be a single, well-structured Markdown document detailing this analysis. Zero tolerance for any deviation from the specified output format.

---

## INPUT SECTIONS OVERVIEW:
1.  `User Task`: The user's description of the bug, observed behavior, expected behavior, and steps to reproduce.
2.  `Guiding Principles`: Your core operational directives as a senior debugging analyst.
3.  `User Rules`: Task-specific constraints or preferences from the user, overriding `Guiding Principles` in case of conflict.
4.  `Output Format & Constraints`: Strict rules for your *only* output: the Markdown Bug Analysis Report.
5.  `File Structure Format Description`: How the provided project files are structured in this prompt (if applicable).
6.  `File Structure`: The current state of the project's files (if applicable to the task).

---

## 1. User Task
No task provided by the user.
*(Example: "When clicking the 'Save' button on the profile page, user data is not updated in the database, although the interface shows a success message. It is expected that the data will be saved. Steps: 1. Log in. 2. Go to profile. 3. Change name. 4. Click 'Save'. 5. Refresh page - name is old.")*

---

## 2. Guiding Principles (Your Senior Debugging Analyst Logic)

### A. Analysis & Understanding (Internal Thought Process - Do NOT output this part):
1.  **Deconstruct Bug Report:** Deeply understand the `User Task` – observed behavior, expected behavior, steps to reproduce (STR), environment details (if provided), and any error messages.
2.  **Contextual Comprehension:** If `File Structure` is provided, analyze it to understand the relevant code modules, functions, data flow, dependencies, and potential areas related to the bug.
3.  **Hypothesis Generation:** Formulate initial hypotheses about potential causes based on the bug description, STR, and code structure. Consider common bug categories (e.g., logic errors, race conditions, data validation issues, environment misconfigurations, third-party integration problems).
4.  **Execution Path Mapping (Mental or Simulated):** Meticulously trace the likely execution path(s) of the code involved in reproducing the bug. Consider:
    *   Entry points for the user action.
    *   Function calls, method invocations, and their sequence.
    *   Conditional branches (if/else, switch statements).
    *   Loops and their termination conditions.
    *   Asynchronous operations, callbacks, promises, event handling.
    *   Data transformations and state changes at each step.
    *   Error handling mechanisms (try/catch blocks, error events).
5.  **Identify Key Checkpoints & Variables:** Determine critical points in the code execution or specific variables whose state (or changes in state) could confirm or refute hypotheses and reveal the bug's origin.
6.  **Information Gap Analysis:** Identify what information is missing that would help confirm/refute hypotheses (e.g., specific log messages, variable values at certain points, network request/response details).
7.  **Assumptions:** If ambiguities exist in `User Task` or `File Structure`, make well-founded assumptions based on common programming practices, the described system behavior, and the provided context. Document these assumptions clearly in the output.
8.  **Consider Edge Cases & Interactions:** Think about how different components interact, potential concurrency issues, error propagation, and edge cases related to input data or system state that might trigger the bug.

### B. Report Generation & Standards:
*   **Clarity & Detail:** The report must clearly explain the analysis process, the traced execution path(s), and the reasoning behind identified potential causes. Use precise language.
*   **Evidence-Based Reasoning:** Base conclusions on the provided `User Task`, `File Structure` (if available), and logical deduction. If speculation is necessary, clearly label it as such and state the confidence level.
*   **Focus on Root Cause(s):** Aim to identify the underlying root cause(s) of the bug, not just its symptoms. Distinguish between correlation and causation.
*   **Actionable Insights for Debugging:** Suggest specific areas of code to inspect further, logging to add (and what data to log), breakpoints to set, or specific tests/scenarios to run to confirm the diagnosis.
*   **Reproducibility Analysis:** Based on the execution path tracing, confirm if the user's STR are logical and sufficient, or suggest refinements if the analysis reveals missing steps or conditions.
*   **Impact Assessment (of the bug):** Briefly describe the potential impact of the bug if not fixed, based on the analysis.
*   **No Code Fixes:** The output is an analysis report, not fixed code. Code snippets illustrating the problematic execution flow, data state, or specific lines of code relevant to the bug are highly encouraged *within the report document* to clarify points.

---

## 3. User Rules
no additional rules
*(Example: "Assume PostgreSQL is used as the DB.", "Focus on backend logic.", "Do not consider UI problems unless they indicate an error in data coming from the backend.")*

---

## 4. Output Format & Constraints (MANDATORY & STRICT)

Your **ONLY** output will be a single, well-structured Markdown document. No other text, explanations, or apologies are permitted outside this Markdown document.

### Markdown Structure (Suggested Outline - Adapt as needed for clarity, maintaining the spirit of each section):

```markdown
# Bug Analysis Report: [Brief Bug Title from User Task]

## 1. Executive Summary
   - Brief description of the analyzed bug.
   - Most likely root cause(s) (if identifiable at this stage).
   - Key code areas/modules involved in the problem.

## 2. Bug Description and Context (from `User Task`)
   - **Observed Behavior:** [What is happening]
   - **Expected Behavior:** [What should be happening]
   - **Steps to Reproduce (STR):** [How to reproduce, according to the user]
   - **Environment (if provided):** [Software versions, OS, browser, etc.]
   - **Error Messages (if any):** [Error text]

## 3. Code Execution Path Analysis
   ### 3.1. Entry Point(s) and Initial State
      - Where does the relevant code execution begin (e.g., API controller, UI event handler, cron job start)?
      - What is the assumed initial state of data/system before executing STR?
   ### 3.2. Key Functions/Modules/Components in the Execution Path
      - List and brief description of the role of main code sections (functions, classes, services) through which execution passes.
      - Description of their presumed responsibilities in the context of the task.
   ### 3.3. Execution Flow Tracing
      - **Step 1:** [User Action / System Event] -> `moduleA.functionX()`
         - **Input Data/State:** [What is passed to `functionX` or what is the state of `moduleA`]
         - **Expected behavior of `functionX`:** [What the function should do]
         - **Observed/Presumed Result:** [What actually happens or what might have gone wrong]
      - **Step 2:** `moduleA.functionX()` calls `moduleB.serviceY()`
         - **Input Data/State:** ...
         - **Expected behavior of `serviceY`:** ...
         - **Observed/Presumed Result:** ...
      - **Step N:** [Final Action / Bug Manifestation Point]
         - **Input Data/State:** ...
         - **Expected Behavior:** ...
         - **Observed/Presumed Result:** [How this leads to the observed bug]
      *(Detail the steps, including conditional branches, loops, error handling. Mermaid.js can be used for sequence diagrams or flowcharts if it improves understanding.)*
      ```mermaid
      sequenceDiagram
          participant User
          participant Frontend
          participant BackendController
          participant ServiceLayer
          participant Database
          User->>Frontend: Clicks "Save" with data X
          Frontend->>BackendController: POST /api/profile (data: X)
          BackendController->>ServiceLayer: updateUser(userId, X)
          ServiceLayer->>Database: UPDATE users SET ... WHERE id = userId
          alt Successful save
              Database-->>ServiceLayer: Rows affected: 1
              ServiceLayer-->>BackendController: {success: true}
              BackendController-->>Frontend: HTTP 200 {success: true}
          else Error or data not changed
              Database-->>ServiceLayer: Rows affected: 0 / Error
              ServiceLayer-->>BackendController: {success: false, error: "..."}
              BackendController-->>Frontend: HTTP 500 or HTTP 200 {success: false}
          end
      ```
   ### 3.4. Data State and Flow Analysis
      - How key variables or data structures change (or should change) along the execution path.
      - Where the data flow might deviate from expected, be lost, or corrupted.

## 4. Potential Root Causes and Hypotheses
   ### 4.1. Hypothesis 1: [Brief description of hypothesis, e.g., "Incorrect input data validation"]
      - **Rationale/Evidence:** Why this is a likely cause, based on execution path analysis and code structure. Which code sections support this hypothesis?
      - **Code (if relevant):** Provide code snippets from `File Structure` that might contain the error or point to it.
        ```[language]
        // Example of relevant code
        if (data.value > MAX_VALUE) { // Possibly, MAX_VALUE is incorrectly defined
            // ...
        }
        ```
      - **How it leads to the bug:** Explain the mechanism by which this cause leads to the observed behavior.
   ### 4.2. Hypothesis 2: [E.g., "Error in SQL update query"]
      - **Rationale/Evidence:** ...
      - **Code (if relevant):** ...
      - **How it leads to the bug:** ...
   *(Add as many hypotheses as necessary. Assess their likelihood.)*
   ### 4.3. Most Likely Cause(s)
      - Justify why certain hypotheses are considered most likely.

## 5. Supporting Evidence from Code (if `File Structure` is provided)
   - Direct references to lines/functions in `File Structure` that confirm the analysis or indicate problematic areas.
   - Identification of incorrect logic, missing checks, or wrong assumptions in the code.

## 6. Recommended Steps for Debugging and Verification
   - **Logging:**
      - Which variables and at what code points should be logged to confirm data flow and state? (e.g., `logger.debug("User data before save in UserService: %s", userData);`)
   - **Breakpoints:**
      - Where is it recommended to set breakpoints and which variables/expressions to inspect?
   - **Test Scenarios/Requests:**
      - What specific input data or scenarios can help isolate the problem? (e.g., "Try saving with a minimal set of valid data", "Check behavior with empty fields")
   - **Clarifying Questions (for user/team):**
      - What additional details might clarify the situation? (e.g., "Does the bug affect all users or only some?", "Were there recent changes in related modules?")

## 7. Bug Impact Assessment
   - Brief description of potential consequences if the bug is not fixed (e.g., data loss, incorrect reports, inability to use key functionality, security breach).

## 8. Assumptions Made During Analysis
   - List any assumptions made during the analysis (e.g., about user input, environment configuration, behavior of third-party libraries, missing information).

## 9. Open Questions / Areas for Further Investigation
   - Areas where additional information is needed for a definitive diagnosis.
   - Aspects of the code or system that remain unclear and require further study.
   - **(Optional) Key points for discussion with the team before starting the fix.**

```

### General Constraints on the Report:
*   **Comprehensive & Detailed:** The report must provide enough detail for the development team to understand the analysis process, possible causes, and suggested verification steps.
*   **Logical & Structured:** The analysis must be presented sequentially and logically.
*   **Objective:** Strive for objectivity, basing conclusions on facts and logic.
*   **Strictly Markdown:** The entire output must be a single Markdown document. Do not include any preambles or concluding remarks outside the Markdown document itself.

---

## 5. File Structure Format Description
The `File Structure` (provided in the next section, if applicable) is formatted as follows:
1.  An initial project directory tree structure (e.g., generated by `tree` or similar).
2.  Followed by the content of each file, using an XML-like structure:
    <file path="RELATIVE/PATH/TO/FILE">
    (File content here)
    </file>
    The `path` attribute contains the project-root-relative path, using forward slashes (`/`).
    File content is the raw text of the file. Each file block is separated by a newline.
    *(This section may be omitted if no file structure is relevant to the task).*

---

## 6. File Structure
arduino 328 servo\
├── include
│   ├── commands.h
│   ├── config.h
│   ├── sensors.h
│   ├── stepper_control.h
│   └── valves.h
├── lib
│   ├── Bounce2
│   │   └── examples
│   │       ├── bounce_basic
│   │       │   └── bounce_basic.ino
│   │       ├── bounce_button
│   │       │   └── bounce_button.ino
│   │       └── more
│   │           ├── bounce_current_duration
│   │           │   └── bounce_current_duration.ino
│   │           ├── bounce_m5stack_atom_key-unit
│   │           │   └── bounce_m5stack_atom_key-unit.ino
│   │           ├── bounce_previous_duration
│   │           │   └── bounce_previous_duration.ino
│   │           ├── bounce_previous_duration_blink_toggle
│   │           │   └── bounce_previous_duration_blink_toggle.ino
│   │           ├── bounceMore
│   │           │   └── bounceMore.ino
│   │           ├── bounceTwo
│   │           │   └── bounceTwo.ino
│   │           ├── change
│   │           │   └── change.ino
│   │           └── retrigger
│   │               └── retrigger.ino
│   ├── GyverStepper
│   │   └── examples
│   │       ├── Planner
│   │       │   ├── PlannerArray
│   │       │   │   └── PlannerArray.ino
│   │       │   ├── PlannerCircle
│   │       │   │   ├── stepperPlot
│   │       │   │   │   └── stepperPlot.pde
│   │       │   │   └── PlannerCircle.ino
│   │       │   ├── PlannerControl
│   │       │   │   └── PlannerControl.ino
│   │       │   ├── PlannerDemo
│   │       │   │   └── PlannerDemo.ino
│   │       │   ├── PlannerHoming
│   │       │   │   └── PlannerHoming.ino
│   │       │   ├── PlannerSpeedControl
│   │       │   │   └── PlannerSpeedControl.ino
│   │       │   └── PlannerTimerISR
│   │       │       ├── PlannerTimerISR.ino
│   │       │       └── timer.ino
│   │       ├── Planner2
│   │       │   ├── PlannerArray
│   │       │   │   ├── stepperPlot
│   │       │   │   │   └── stepperPlot.pde
│   │       │   │   └── PlannerArray.ino
│   │       │   ├── PlannerCircle
│   │       │   │   ├── stepperPlot
│   │       │   │   │   └── stepperPlot.pde
│   │       │   │   └── PlannerCircle.ino
│   │       │   └── PlannerCircleISR
│   │       │       ├── stepperPlot
│   │       │       │   └── stepperPlot.pde
│   │       │       ├── PlannerCircleISR.ino
│   │       │       └── timer.ino
│   │       ├── Stepper
│   │       │   ├── accelDeccelButton
│   │       │   │   └── accelDeccelButton.ino
│   │       │   ├── demo
│   │       │   │   └── demo.ino
│   │       │   ├── endSwitch
│   │       │   │   └── endSwitch.ino
│   │       │   ├── externalDriver
│   │       │   │   └── externalDriver.ino
│   │       │   ├── multiStepper
│   │       │   │   └── multiStepper.ino
│   │       │   ├── potPos
│   │       │   │   └── potPos.ino
│   │       │   ├── potSpeed
│   │       │   │   └── potSpeed.ino
│   │       │   ├── smoothAlgorithm
│   │       │   │   └── smoothAlgorithm.ino
│   │       │   ├── speed
│   │       │   │   └── speed.ino
│   │       │   ├── speedSerialControl
│   │       │   │   └── speedSerialControl.ino
│   │       │   ├── stop
│   │       │   │   └── stop.ino
│   │       │   ├── sweep
│   │       │   │   └── sweep.ino
│   │       │   └── timerISR
│   │       │       └── timerISR.ino
│   │       └── Stepper2
│   │           ├── homing
│   │           │   └── homing.ino
│   │           ├── SpeedControl
│   │           │   └── SpeedControl.ino
│   │           ├── StepperControl
│   │           │   └── StepperControl.ino
│   │           ├── sweep
│   │           │   └── sweep.ino
│   │           ├── sweep_FAST_PROFILE
│   │           │   └── sweep_FAST_PROFILE.ino
│   │           └── sweepISR
│   │               ├── sweepISR.ino
│   │               └── timer.ino
│   └── SerialCommand
│       ├── examples
│       │   └── SerialCommandExample
│       │       └── SerialCommandExample.pde
│       ├── keywords.txt
│       ├── library.json
│       ├── readme.md
│       ├── SerialCommand.cpp
│       └── SerialCommand.h
├── src
│   ├── commands.cpp
│   ├── main.ino
│   ├── sensors.cpp
│   ├── stepper_control.cpp
│   └── valves.cpp
├── .gitignore
├── platformio.ini
└── README.md

<file path="include/commands.h">
#ifndef COMMANDS_H
#define COMMANDS_H

#include <SerialCommand.h>
#include <NBHX711.h>
#include "config.h"
#include "stepper_control.h"
#include "sensors.h"
#include "valves.h"

// Объявление внешних переменных
extern SerialCommand sCmd;
extern NBHX711 scale;

// Сообщения команд
#ifndef MSG_RECEIVED
#define MSG_RECEIVED "RECEIVED"
#endif

#ifndef MSG_COMPLETED
#define MSG_COMPLETED "COMPLETED"
#endif

#ifndef MSG_ERROR
#define MSG_ERROR "ERROR"
#endif

#ifndef MSG_TIMEOUT
#define MSG_TIMEOUT "TIMEOUT"
#endif

#ifndef MSG_NO_POSITION
#define MSG_NO_POSITION "ERR_NO_POSITION"
#endif

#ifndef MSG_HOMING_TIMEOUT
#define MSG_HOMING_TIMEOUT "ERR_HOMING_TIMEOUT"
#endif

#ifndef MSG_MISSING_PARAMETER
#define MSG_MISSING_PARAMETER "ERR_MISSING_PARAMETER"
#endif

#ifndef MSG_INVALID_PARAMETER
#define MSG_INVALID_PARAMETER "ERR_INVALID_PARAMETER"
#endif

// Настройка обработчиков команд
void setupCommandHandlers();

// Отправка сообщения о получении команды
void sendReceived();

// Отправка сообщения о завершении команды
void sendCompleted();

// Отправка сообщения об ошибке
void sendError(const char* errorMsg);

// Обработка неизвестной команды
void handleUnrecognized(const char* command);

// Тестовая функция для проверки связи
void testCommand();

// Обработчики команд движения
void handleMoveMulti();
void handleMoveMultizone();
void handleMoveRRight();

// Обработчики команд для новых двигателей E0 и E1
void handleClamp();
void handleClampZero();

// Обработчики команд хоминга
void handleZeroMulti();
void handleZeroMultizone();
void handleZeroRRight();

// Обработчики команд управления насосом
void handlePumpOn();
void handlePumpOff();

// Обработчики команд управления клапанами
void handleKl1On();
void handleKl2On();
void handleKl3On();
void handleKl1Off();
void handleKl2Off();
void handleKl3Off();

// Обработчики команд чтения датчиков
void handleWeight();
void handleRawWeight();
void handleWeightDebug();
void handleStateRotor();
void handleWaste();
void handleCalibrateWeight();
void handleCalibrateWeightFactor();
void handleWeightReportOn();
void handleWeightReportOff();

// Обработчики диагностических команд
void handleCheckMultiEndstop();
void handleCheckMultizoneEndstop();
void handleCheckRRightEndstop();
void handleCheckAllEndstops();


// Обработчики команд для клапанов
void handleKl1Toggle();
void handleKl2Toggle();
void handleKl3Toggle();
void handleKl1Off();
void handleKl2Off();
void handleKl3Off();

// Обработчики команд для насоса
void handlePumpToggle();
void handlePumpOn();
void handlePumpOff();

// Обработчики команд для роторов
void handleRotorForward();
void handleRotorReverse();
void handleRotorStop();

// Обработчик команд для весов
void handleGetWeight();

#endif // COMMANDS_H 
</file>
<file path="include/config.h">
#ifndef CONFIG_H
#define CONFIG_H

#include <Arduino.h>

// ============== PIN ASSIGNMENT ==============
// Stepper Multi (X на плате)
#define MULTI_STEP_PIN A0
#define MULTI_DIR_PIN A1
#define MULTI_ENABLE_PIN 38
#define MULTI_ENDSTOP_PIN 3    // X+ на плате

// Pump (digital output)
#define PUMP_PIN 18

// Stepper Multizone (Y на плате)
#define MULTIZONE_STEP_PIN A6
#define MULTIZONE_DIR_PIN A7
#define MULTIZONE_ENABLE_PIN A2
#define MULTIZONE_ENDSTOP_PIN 2    // Y+ на плате

// Stepper RRight (Z на плате)
#define RRIGHT_STEP_PIN 46
#define RRIGHT_DIR_PIN 48
#define RRIGHT_ENABLE_PIN A8
#define RRIGHT_ENDSTOP_PIN 14    // Z+ на плате

// Stepper E0 (E0 на схеме распиновки)
#define E0_STEP_PIN 26
#define E0_DIR_PIN 28
#define E0_ENABLE_PIN 24

// Stepper E1 (E1 на схеме распиновки)
#define E1_STEP_PIN 36
#define E1_DIR_PIN 34
#define E1_ENABLE_PIN 30

// Датчик для функции clamp_zero (изменен с 3 на 15, чтобы избежать конфликта)
#define CLAMP_SENSOR_PIN 15

// Valves (используем свободные пины)
#define KL1_PIN 8
#define KL2_PIN 10
#define KL3_PIN 7

// Sensors
// HX711 датчик веса - используем доступные пины для MKS Gen L v1
#define WEIGHT_SENSOR_SCK 42    // SCK пин для HX711
#define WEIGHT_SENSOR_DT 40     // DT пин для HX711

#define WASTE_PIN 19
#define ROTOR_PINS {27, 29, 23, 25}

// ============== CONSTANTS ==============
const int HOMING_SPEED = 300;     // steps/sec
const int HOMING_TIMEOUT = 10000; // ms
const int CLAMP_SPEED = 300;      // steps/sec для функции clamp
const int CLAMP_ZERO_SPEED = 200; // steps/sec для функции clamp_zero
const int CLAMP_ACCELERATION = 10; // steps/sec^2 для функций clamp и clamp_zero

// ============== RESPONSE MESSAGES ==============
#define MSG_OK "OK"
#define MSG_ERROR "ERR"
#define MSG_RECEIVED "RECEIVED"
#define MSG_COMPLETED "COMPLETED"
#define MSG_HOMING_TIMEOUT "HOMING TIMEOUT"
#define MSG_NO_POSITION "NO POSITION"
#define MSG_INVALID_VALUE "INVALID VALUE"
#define MSG_MISSING_PARAMETER "MISSING PARAMETER"
#define MSG_INVALID_PARAMETER "INVALID PARAMETER"

#endif // CONFIG_H 
</file>
<file path="include/sensors.h">
#ifndef SENSORS_H
#define SENSORS_H

#include <stdint.h>
#include "config.h"

// Инициализация пинов датчиков
void initializeSensors();

// Чтение состояния ротора
void readRotorState(char* stateBuffer);

// Чтение состояния датчика отходов
bool readWasteSensor();

// Чтение состояния концевых выключателей
bool readEndstopState(int endstopPin);

#endif // SENSORS_H 
</file>
<file path="include/stepper_control.h">
#ifndef STEPPER_CONTROL_H
#define STEPPER_CONTROL_H

#include <GyverStepper2.h>
#include <stdint.h>
#include "config.h"

// Объявления шаговых двигателей
extern GStepper2<STEPPER2WIRE> multiStepper;
extern GStepper2<STEPPER2WIRE> multizoneSteper;
extern GStepper2<STEPPER2WIRE> rRightStepper;
extern GStepper2<STEPPER2WIRE> e0Stepper;
extern GStepper2<STEPPER2WIRE> e1Stepper;

// Инициализация шаговых двигателей
void initializeSteppers();

// Установка позиции для двигателя
bool setStepperPosition(GStepper2<STEPPER2WIRE>& stepper, long position);

// Выполнение хоминга для двигателя
bool homeStepperMotor(GStepper2<STEPPER2WIRE>& stepper, int endstopPin);

// Синхронное вращение двигателей E0 и E1
bool clampMotors(long steps);

// Обнуление двигателей E0 и E1 по датчику D3
bool clampZeroMotors();

#endif // STEPPER_CONTROL_H 
</file>
<file path="include/valves.h">
#ifndef VALVES_H
#define VALVES_H

#include <stdint.h>
#include "config.h"

// Инициализация пинов клапанов и насоса
void initializeValves();

// Управление насосом
void setPumpState(bool state);

// Переключение состояния клапана
void toggleValveState(int valvePin);

// Установка состояния клапана
void setValveState(int valvePin, bool state);

// Включение клапана
void turnValveOn(int valvePin);

// Выключение клапана
void turnValveOff(int valvePin);

#endif // VALVES_H 
</file>
<file path="lib/Bounce2/examples/bounce_basic/bounce_basic.ino">

/*
  DESCRIPTION
  ====================
  Simple example of the Bounce library that switches a LED when
  a state change (from HIGH to LOW) is triggered (for example when a button is pressed).

  Set BOUNCE_PIN to the pin attached to the input (a button for example).
  Set LED_PIN to the pin attached to a LED.

*/

// WE WILL attach() THE Bounce INSTANCE TO THE FOLLOWING PIN IN setup()
#define BOUNCE_PIN 2

// DEFINE THE PIN FOR THE LED :
// 1) SOME BOARDS HAVE A DEFAULT LED (LED_BUILTIN)
#define LED_PIN LED_BUILTIN
// 2) OTHERWISE SET YOUR OWN PIN
// #define LED_PIN 13

// Include the Bounce2 library found here :
// https://github.com/thomasfredericks/Bounce2
#include <Bounce2.h>


// INSTANTIATE A Bounce OBJECT
Bounce bounce = Bounce();

// SET A VARIABLE TO STORE THE LED STATE
int ledState = LOW;

void setup() {

  // BOUNCE SETUP

  // SELECT ONE OF THE FOLLOWING :
  // 1) IF YOUR INPUT HAS AN INTERNAL PULL-UP
  bounce.attach( BOUNCE_PIN ,  INPUT_PULLUP ); // USE INTERNAL PULL-UP
  // 2) IF YOUR INPUT USES AN EXTERNAL PULL-UP
  //bounce.attach( BOUNCE_PIN, INPUT ); // USE EXTERNAL PULL-UP

  // DEBOUNCE INTERVAL IN MILLISECONDS
  bounce.interval(5); // interval in ms

  // LED SETUP
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, ledState);

}

void loop() {
  // Update the Bounce instance (YOU MUST DO THIS EVERY LOOP)
  bounce.update();

  // <Bounce>.changed() RETURNS true IF THE STATE CHANGED (FROM HIGH TO LOW OR LOW TO HIGH)
  if ( bounce.changed() ) {
    // THE STATE OF THE INPUT CHANGED
    // GET THE STATE
    int deboucedInput = bounce.read();
    // IF THE CHANGED VALUE IS LOW
    if ( deboucedInput == LOW ) {
      ledState = !ledState; // SET ledState TO THE OPPOSITE OF ledState
      digitalWrite(LED_PIN,ledState); // WRITE THE NEW ledState
    }
  }



}

</file>
<file path="lib/Bounce2/examples/bounce_button/bounce_button.ino">

/* 
 DESCRIPTION
 ====================
 This is an example of the Bounce2::Button class. 
 When the user presses a physical button, it toggles a LED on or off.
 The Button class matches an electrical state to a physical action. 
 Use .setPressedState(LOW or HIGH) to set the detection state for when the button is pressed.


 INSCRUCTIONS
 ====================

 Set BUTTON_PIN to the pin attached to the button.
 Set LED_PIN to the pin attached to a LED.
 
 */

 // WE WILL attach() THE BUTTON TO THE FOLLOWING PIN IN setup()
#define BUTTON_PIN 2 

// DEFINE THE PIN FOR THE LED :
// 1) SOME BOARDS HAVE A DEFAULT LED (LED_BUILTIN)
//#define LED_PIN LED_BUILTIN
// 2) OTHERWISE SET YOUR OWN PIN
#define LED_PIN 13
 
// Include the Bounce2 library found here :
// https://github.com/thomasfredericks/Bounce2
#include <Bounce2.h>

// INSTANTIATE A Button OBJECT FROM THE Bounce2 NAMESPACE
Bounce2::Button button = Bounce2::Button();



// SET A VARIABLE TO STORE THE LED STATE
int ledState = LOW;

void setup() {

  // BUTTON SETUP 
  
  // SELECT ONE OF THE FOLLOWING :
  // 1) IF YOUR BUTTON HAS AN INTERNAL PULL-UP
  // button.attach( BUTTON_PIN ,  INPUT_PULLUP ); // USE INTERNAL PULL-UP
  // 2) IF YOUR BUTTON USES AN EXTERNAL PULL-UP
  button.attach( BUTTON_PIN, INPUT ); // USE EXTERNAL PULL-UP

  // DEBOUNCE INTERVAL IN MILLISECONDS
  button.interval(5); 

  // INDICATE THAT THE LOW STATE CORRESPONDS TO PHYSICALLY PRESSING THE BUTTON
  button.setPressedState(LOW); 
  
  // LED SETUP
  pinMode(LED_PIN,OUTPUT);
  digitalWrite(LED_PIN,ledState);

}

void loop() {
  // UPDATE THE BUTTON
  // YOU MUST CALL THIS EVERY LOOP
  button.update();

  // <Button>.pressed() RETURNS true IF THE STATE CHANGED
  // AND THE CURRENT STATE MATCHES <Button>.setPressedState(<HIGH or LOW>);
  // WHICH IS LOW IN THIS EXAMPLE AS SET WITH button.setPressedState(LOW); IN setup()
  if ( button.pressed() ) {
    
    // TOGGLE THE LED STATE : 
    ledState = !ledState; // SET ledState TO THE OPPOSITE OF ledState
    digitalWrite(LED_PIN,ledState); // WRITE THE NEW ledState

  }
}

</file>
<file path="lib/Bounce2/examples/more/bounce_current_duration/bounce_current_duration.ino">

/*
  DESCRIPTION
  ====================
  Simple example of the Bounce library that switches on a LED when
  the decounced input is held for more than 1000 milliseconds.

  Set BOUNCE_PIN to the pin attached to the input (a button for example).
  Set LED_PIN to the pin attached to a LED.

*/

// WE WILL attach() THE Bounce INSTANCE TO THE FOLLOWING PIN IN setup()
#define BOUNCE_PIN 2

// DEFINE THE PIN FOR THE LED :
// 1) SOME BOARDS HAVE A DEFAULT LED (LED_BUILTIN)
#define LED_PIN LED_BUILTIN
// 2) OTHERWISE SET YOUR OWN PIN
// #define LED_PIN 13

// Include the Bounce2 library found here :
// https://github.com/thomasfredericks/Bounce2
#include <Bounce2.h>


// INSTANTIATE A Bounce OBJECT.
Bounce bounce = Bounce();
 
// SET A VARIABLE TO STORE THE LED STATE
int ledState = LOW;

void setup() {

  // BOUNCE SETUP

  // SELECT ONE OF THE FOLLOWING :
  // 1) IF YOUR INPUT HAS AN INTERNAL PULL-UP
  bounce.attach( BOUNCE_PIN ,  INPUT_PULLUP ); // USE INTERNAL PULL-UP
  // 2) IF YOUR INPUT USES AN EXTERNAL PULL-UP
  //bounce.attach( BOUNCE_PIN, INPUT ); // USE EXTERNAL PULL-UP

  // DEBOUNCE INTERVAL IN MILLISECONDS
  bounce.interval(5); // interval in ms

  // LED SETUP
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, ledState);

}

void loop() {
  // Update the Bounce instance (YOU MUST DO THIS EVERY LOOP)
  bounce.update();

  // GET THE STATE WITH <Bounce.read()>
  int debouncedState = bounce.read();

  // <Bounce>.duration() RETURNS THE TIME IN MILLISECONDS THE CURRENT STATE HAS BEEN HELD.
  // SO WE CHECK IF THE STATE IS LOW AND IF IT HAS BEEN LOW FOR MORE THAN 1 SECOND.
  if ( debouncedState == LOW && bounce.currentDuration() > 1000 ) {
    digitalWrite(LED_PIN,HIGH); // TURN THE LED ON
  } else {
    digitalWrite(LED_PIN,LOW); // TURN THE LED OFF
  }
    
}

</file>
<file path="lib/Bounce2/examples/more/bounce_m5stack_atom_key-unit/bounce_m5stack_atom_key-unit.ino">
// Le code de base pour le M5Stack Atom

// Inclure la librairie M5 (version pour M5Atom) :
// https://github.com/m5stack/M5Atom
#include <M5Atom.h>

// Inclure la librairie FastLED qui va gérer le pixel :
// https://github.com/FastLED/FastLED
#include <FastLED.h>

// Un tableau qui contient une variable de type CRGB.
// Il y a un seul pixel, mais il doit être dans un tableau.
// CRGB est un type de couleur défini par la lirairie FastLed :
// https://github.com/FastLED/FastLED/wiki/Pixel-reference#crgb-reference
CRGB mesPixels[1];

#include <Bounce2.h>
Bounce2::Button button = Bounce2::Button();  // INSTANTIATE A Bounce2::Button OBJECT

bool ledToggle = false;

void setup() {
  // Démarrer la libraire M5 avec toutes les options de pré-configuration désactivées :
  M5.begin(false, false, false);

  // Démarrer la connexion sérielle :
  Serial.begin(115200);

  // Ajouter le pixel (il y en a un seul) du M5Atom à la librairie FastLED :
  FastLED.addLeds<WS2812, DATA_PIN, GRB>(mesPixels, 1);

  // Animation de démarrage
  while (millis() < 5000) {
    mesPixels[0] = CHSV((millis() / 5) % 255, 255, 255 - (millis() * 255 / 5000));
    FastLED.show();
    delay(50);
  }
  mesPixels[0] = CRGB(0, 0, 0);
  FastLED.show();

  button.attach(32, INPUT_PULLUP);
  button.interval(5);
  button.setPressedState(LOW);
}

void loop() {
  // Toujours inclure M5.update() au début de loop() :
  M5.update();

  // UPDATE THE BUTTON BY CALLING .update() AT THE BEGINNING OF THE LOOP:
  button.update();

  // IF THE BUTTON WAS PRESSED THIS LOOP:
  if (button.pressed()) {
    // DO SOMETHING IF THE BUTTON WAS PRESSED THIS LOOP...

    if (ledToggle) {
      ledToggle = false;
      mesPixels[0] = CRGB(0, 0, 0);
    } else {
      ledToggle = true;
      mesPixels[0] = CRGB(255, 255, 255);
    }

    FastLED.show();
  }
}
</file>
<file path="lib/Bounce2/examples/more/bounce_previous_duration/bounce_previous_duration.ino">

/*
  DESCRIPTION
  ====================
  When the debounced input goes from LOW to HIGH, the LED will turn on for the same time
  the debounced input was held LOW.

  Set BOUNCE_PIN to the pin attached to the input (a button for example).
  Set LED_PIN to the pin attached to a LED.

*/

// WE WILL attach() THE Bounce INSTANCE TO THE FOLLOWING PIN IN setup()
#define BOUNCE_PIN 2

// DEFINE THE PIN FOR THE LED :
// 1) SOME BOARDS HAVE A DEFAULT LED (LED_BUILTIN)
#define LED_PIN LED_BUILTIN
// 2) OTHERWISE SET YOUR OWN PIN
// #define LED_PIN 13

// Include the Bounce2 library found here :
// https://github.com/thomasfredericks/Bounce2
#include <Bounce2.h>


// INSTANTIATE A Bounce OBJECT.
Bounce bounce = Bounce();

// SET A VARIABLE TO STORE THE INTERVAL FOR HOW LONG TO KEEP THE LED HIGH
unsigned long ledHighInterval;

// SET A VARIABLE TO STORE THE START TIME WHEN THE LED WAS TURNED HIGH
unsigned long ledHighLastTime;

void setup() {

  // BOUNCE SETUP

  // SELECT ONE OF THE FOLLOWING :
  // 1) IF YOUR INPUT HAS AN INTERNAL PULL-UP
  bounce.attach( BOUNCE_PIN ,  INPUT_PULLUP ); // USE INTERNAL PULL-UP
  // 2) IF YOUR INPUT USES AN EXTERNAL PULL-UP
  //bounce.attach( BOUNCE_PIN, INPUT ); // USE EXTERNAL PULL-UP

  // DEBOUNCE INTERVAL IN MILLISECONDS
  bounce.interval(5); // interval in ms

  // LED SETUP
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);

}

void loop() {
  // Update the Bounce instance (YOU MUST DO THIS EVERY LOOP)
  bounce.update();

  // <Bounce>.rose() RETURNS true IF THE STATE JUST WENT FROM LOW TO HIGH
  if ( bounce.rose() ) {
    digitalWrite(LED_PIN, HIGH); // TURN ON THE LED
    ledHighLastTime = millis();
    ledHighInterval = bounce.previousDuration();
  }

  // IF WE HAVE TO BLINK THE LED
  if ( millis() - ledHighLastTime > ledHighInterval ) {
    digitalWrite(LED_PIN, LOW);
  } else {
    digitalWrite(LED_PIN, HIGH);
  }

}

</file>
<file path="lib/Bounce2/examples/more/bounce_previous_duration_blink_toggle/bounce_previous_duration_blink_toggle.ino">

/*
  DESCRIPTION
  ====================
  Simple example of the Bounce library that switches the state of a LED
  when the debounced input goes from LOW to HIGH. 

  Also if the debounced input was previously held LOW for more than 1000 milliseconds,
  the LED will blink.

  Set BOUNCE_PIN to the pin attached to the input (a button for example).
  Set LED_PIN to the pin attached to a LED.

*/

// WE WILL attach() THE Bounce INSTANCE TO THE FOLLOWING PIN IN setup()
#define BOUNCE_PIN 2

// DEFINE THE PIN FOR THE LED :
// 1) SOME BOARDS HAVE A DEFAULT LED (LED_BUILTIN)
#define LED_PIN LED_BUILTIN
// 2) OTHERWISE SET YOUR OWN PIN
// #define LED_PIN 13

// Include the Bounce2 library found here :
// https://github.com/thomasfredericks/Bounce2
#include <Bounce2.h>


// INSTANTIATE A Bounce OBJECT.
Bounce bounce = Bounce();
 
// SET A VARIABLE TO STORE THE LED STATE
int ledState = LOW;

// SET A VARIABLE TO STORE THE BLINKING STATE
bool blinkLed = false;
// SET A VARIABLE TO STORE THE LAST TIME THE LED BLINKED
unsigned long blinkLedLastTime;

void setup() {

  // BOUNCE SETUP

  // SELECT ONE OF THE FOLLOWING :
  // 1) IF YOUR INPUT HAS AN INTERNAL PULL-UP
  bounce.attach( BOUNCE_PIN ,  INPUT_PULLUP ); // USE INTERNAL PULL-UP
  // 2) IF YOUR INPUT USES AN EXTERNAL PULL-UP
  //bounce.attach( BOUNCE_PIN, INPUT ); // USE EXTERNAL PULL-UP

  // DEBOUNCE INTERVAL IN MILLISECONDS
  bounce.interval(5); // interval in ms

  // LED SETUP
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, ledState);

}

void loop() {
  // Update the Bounce instance (YOU MUST DO THIS EVERY LOOP)
  bounce.update();

  // <Bounce>.changed() RETURNS true IF THE STATE CHANGED (FROM HIGH TO LOW OR LOW TO HIGH)
  if ( bounce.changed() ) {
    // THE STATE OF THE INPUT CHANGED
    // GET THE STATE
    int deboucedInput = bounce.read();
    // IF THE CHANGED VALUE IS HIGH
    if ( deboucedInput == HIGH ) {
      ledState = !ledState; // SET ledState TO THE OPPOSITE OF ledState
      digitalWrite(LED_PIN,ledState); // WRITE THE NEW ledState
      // IF THE DURATION OF THE PREVIOUS STATE (LOW IN THIS CASE) WAS HELD LONGER THAN 1000 MILLISECONDS:
      if ( bounce.previousDuration() > 1000 ) blinkLed = true;
      else blinkLed = false;
    } 
  }

  // IF WE HAVE TO BLINK THE LED
  if ( blinkLed ) {
    if ( millis() - blinkLedLastTime > 500 ) {
      blinkLedLastTime = millis();
      ledState = !ledState; // SET ledState TO THE OPPOSITE OF ledState
      digitalWrite(LED_PIN,ledState); // WRITE THE NEW ledState
    }
  }
    
}

</file>
<file path="lib/Bounce2/examples/more/bounceMore/bounceMore.ino">
// Detect the falling edge of multiple buttons.
// Eight buttons with internal pullups.
// Toggles a LED when any button is pressed.
// Buttons on pins 2,3,4,5,6,7,8,9

// Include the Bounce2 library found here :
// https://github.com/thomasfredericks/Bounce2
#include <Bounce2.h>

#define LED_PIN 13

#define NUM_BUTTONS 8
const uint8_t BUTTON_PINS[NUM_BUTTONS] = {2, 3, 4, 5, 6, 7, 8, 9};

int ledState = LOW;

Bounce * buttons = new Bounce[NUM_BUTTONS];

void setup() {

  for (int i = 0; i < NUM_BUTTONS; i++) {
    buttons[i].attach( BUTTON_PINS[i] , INPUT_PULLUP  );       //setup the bounce instance for the current button
    buttons[i].interval(25);              // interval in ms
  }

  // Setup the LED :
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, ledState);


}

void loop() {

  bool needToToggleLed = false;


  for (int i = 0; i < NUM_BUTTONS; i++)  {
    // Update the Bounce instance :
    buttons[i].update();
    // If it fell, flag the need to toggle the LED
    if ( buttons[i].fell() ) {
      needToToggleLed = true;
    }
  }

  // if a LED toggle has been flagged :
  if ( needToToggleLed ) {
    // Toggle LED state :
    ledState = !ledState;
    digitalWrite(LED_PIN, ledState);
  }


}


</file>
<file path="lib/Bounce2/examples/more/bounceTwo/bounceTwo.ino">

/* 
 DESCRIPTION
 ====================
 Simple example of the Bounce library that switches the debug LED when 
 either of 2 buttons are pressed.
 */
 
// Include the Bounce2 library found here :
// https://github.com/thomasfredericks/Bounce2
#include <Bounce2.h>

#define BUTTON_PIN_1 2
#define BUTTON_PIN_2 3


#define LED_PIN 13

// Instantiate a Bounce object
Bounce debouncer1 = Bounce(); 

// Instantiate another Bounce object
Bounce debouncer2 = Bounce(); 

void setup() {

  // Setup the first button with an internal pull-up :
  pinMode(BUTTON_PIN_1,INPUT_PULLUP);
  // After setting up the button, setup the Bounce instance :
  debouncer1.attach(BUTTON_PIN_1);
  debouncer1.interval(5); // interval in ms
  
   // Setup the second button with an internal pull-up :
  pinMode(BUTTON_PIN_2,INPUT_PULLUP);
  // After setting up the button, setup the Bounce instance :
  debouncer2.attach(BUTTON_PIN_2);
  debouncer2.interval(5); // interval in ms


  //Setup the LED :
  pinMode(LED_PIN,OUTPUT);

}

void loop() {
  // Update the Bounce instances :
  debouncer1.update();
  debouncer2.update();

  // Get the updated value :
  int value1 = debouncer1.read();
  int value2 = debouncer2.read();

  // Turn on the LED if either button is pressed :
  if ( value1 == LOW || value2 == LOW ) {
    digitalWrite(LED_PIN, HIGH );
  } 
  else {
    digitalWrite(LED_PIN, LOW );
  }

}



</file>
<file path="lib/Bounce2/examples/more/change/change.ino">

// This example toggles the debug LED (pin 13) on or off
// when a button on pin 2 is pressed.

// Include the Bounce2 library found here :
// https://github.com/thomasfredericks/Bounce2
#include <Bounce2.h>

#define BUTTON_PIN 2
#define LED_PIN 13

int ledState = LOW;


Bounce debouncer = Bounce(); // Instantiate a Bounce object

void setup() {
  
  debouncer.attach(BUTTON_PIN,INPUT_PULLUP); // Attach the debouncer to a pin with INPUT_PULLUP mode
  debouncer.interval(25); // Use a debounce interval of 25 milliseconds
  
  
  pinMode(LED_PIN,OUTPUT); // Setup the LED
  digitalWrite(LED_PIN,ledState);
 
}

void loop() {

   debouncer.update(); // Update the Bounce instance
   
   if ( debouncer.fell() ) {  // Call code if button transitions from HIGH to LOW
     ledState = !ledState; // Toggle LED state
     digitalWrite(LED_PIN,ledState); // Apply new LED state
   }
}


</file>
<file path="lib/Bounce2/examples/more/retrigger/retrigger.ino">

/* 
DESCRIPTION
====================
Example of the bounce library that shows how to retrigger an event when a button is held down.
In this case, the debug LED will blink every 500 ms as long as the button is held down.
Open the Serial Monitor (57600 baud) for debug messages.

*/

// Include the Bounce2 library found here :
// https://github.com/thomasfredericks/Bounce2
#include <Bounce2.h>


#define BUTTON_PIN 2
#define LED_PIN 13

// Instantiate a Bounce object
Bounce debouncer = Bounce(); 

int buttonState;
unsigned long buttonPressTimeStamp;

int ledState;

void setup() {
  
  Serial.begin(57600);
  
  // Setup the button
  pinMode(BUTTON_PIN,INPUT);
  // Activate internal pull-up
  digitalWrite(BUTTON_PIN,HIGH);
  
  // After setting up the button, setup debouncer
  debouncer.attach(BUTTON_PIN);
  debouncer.interval(5);
  
  //Setup the LED
  pinMode(LED_PIN,OUTPUT);
  digitalWrite(LED_PIN,ledState);
  
}

void loop() {
 // Update the debouncer and get the changed state
  boolean changed = debouncer.update();


  
  if ( changed ) {
       // Get the update value
     int value = debouncer.read();
    if ( value == HIGH) {
       ledState = LOW;
       digitalWrite(LED_PIN, ledState );
   
       buttonState = 0;
       Serial.println("Button released (state 0)");
   
   } else {
          ledState = HIGH;
       digitalWrite(LED_PIN, ledState );
       
         buttonState = 1;
         Serial.println("Button pressed (state 1)");
         buttonPressTimeStamp = millis();
     
   }
  }
  
  if  ( buttonState == 1 ) {
    if ( millis() - buttonPressTimeStamp >= 500 ) {
         buttonPressTimeStamp = millis();
         if ( ledState == HIGH ) ledState = LOW;
         else if ( ledState == LOW ) ledState = HIGH;
         digitalWrite(LED_PIN, ledState );
        Serial.println("Retriggering button");
    }
  }
 
 
}



</file>
<file path="lib/GyverStepper/examples/Planner/PlannerArray/PlannerArray.ino">
// пример с записанным в памяти маршрутом
// смотри график

int path[][2] = {
  {10, 10},
  {100, 5},
  {200, 200},
  {150, 150},
  {0, 0},
  {0, 50},
};

// количество точек (пусть компилятор сам считает)
// как вес всего массива / (2+2) байта
int nodeAmount = sizeof(path) / 4;

#include "GyverPlanner.h"
Stepper<STEPPER2WIRE> stepper1(2, 5);
Stepper<STEPPER2WIRE> stepper2(3, 6);
GPlanner<STEPPER2WIRE, 2> planner;

void setup() {
  Serial.begin(115200);  
  // добавляем шаговики на оси
  planner.addStepper(0, stepper1);  // ось 0
  planner.addStepper(1, stepper2);  // ось 1

  // устанавливаем ускорение и скорость
  planner.setAcceleration(100);
  planner.setMaxSpeed(300);
}

int count = 0;  // счётчик точек маршрута
void loop() {
  // здесь происходит движение моторов, вызывать как можно чаще
  planner.tick();

  // вернёт true, если все моторы доехали
  if (planner.ready()) {
    
    if (count < nodeAmount) {         // ограничиваем на количество точек, чтобы не бахнуло
      planner.setTarget(path[count]); // загружаем новую точку (начнётся с 0)
      count++;
    }
  }

  // асинхронно вывожу в порт графики
  static uint32_t tmr;
  if (millis() - tmr >= 20) {
    tmr = millis();
    Serial.print(stepper1.pos);
    Serial.print(',');
    Serial.println(stepper2.pos);
  }
}

</file>
<file path="lib/GyverStepper/examples/Planner/PlannerCircle/stepperPlot/stepperPlot.pde">
String port = "COM6";   // имя порта

import processing.serial.*;
Serial myPort;

void setup() {
  size(500, 500);
  myPort = new Serial(this, port, 115200);
  fill(0);
  noStroke();
}

void draw() {  
  if (myPort.available() > 0) {
    String str = myPort.readStringUntil('\n').trim();
    if (str != null) {      
      String[] pos = split(str, ',');
      int x = int(pos[0]);
      int y = int(pos[1]);
      fill(10);
      circle(x+10, y+10, 4);
      fill(200, 1);
      rect(0, 0, width, height);
    }
  }
}

</file>
<file path="lib/GyverStepper/examples/Planner/PlannerCircle/PlannerCircle.ino">
// пример с записанным в памяти маршрутом окружности
// работу можно посмотреть в плоттере, а лучше в приложенном stepperPlot

const int pointAm = 30;     // количество точек в круге
int radius = 100;           // радиус круга
int32_t path[pointAm + 2][2];     // буфер круга

#include "GyverPlanner.h"
Stepper<STEPPER2WIRE> stepper1(2, 5);
Stepper<STEPPER2WIRE> stepper2(3, 6);
GPlanner<STEPPER2WIRE, 2> planner;

void setup() {
  Serial.begin(115200);
  // добавляем шаговики на оси
  planner.addStepper(0, stepper1);  // ось 0
  planner.addStepper(1, stepper2);  // ось 1

  // устанавливаем ускорение и скорость
  planner.setAcceleration(500);
  planner.setMaxSpeed(500);

  // заполняем буфер
  for (int i = 0; i <= pointAm; i++) {
    path[i + 1][0] = radius + radius * cos(TWO_PI * i / pointAm);
    path[i + 1][1] = radius + radius * sin(TWO_PI * i / pointAm);
  }
}

int count = 0;  // счётчик точек маршрута
void loop() {
  // здесь происходит движение моторов, вызывать как можно чаще
  planner.tick();

  // вернёт true, если все моторы доехали
  if (planner.ready()) {
    planner.setTarget(path[count]); // загружаем новую точку (начнётся с 0)
    if (++count >= sizeof(path) / 8) count = 0;
  }

  // асинхронно вывожу в порт графики
  static uint32_t tmr;
  if (millis() - tmr >= 20) {
    tmr = millis();
    Serial.print(stepper1.pos);
    Serial.print(',');
    Serial.println(stepper2.pos);
  }
}
</file>
<file path="lib/GyverStepper/examples/Planner/PlannerControl/PlannerControl.ino">
// здесь у нас моторы движутся по трём точкам траектории
// можно открыть плоттер, наблюать за этим и отправлять команды:
// s - стоп
// b - тормоз
// p - пауза
// r - продолжить

#include "GyverPlanner.h"
Stepper<STEPPER2WIRE> stepper1(2, 5);
Stepper<STEPPER2WIRE> stepper2(3, 6);
GPlanner<STEPPER2WIRE, 2> planner;

void setup() {
  Serial.begin(57600);
  // добавляем шаговики на оси
  planner.addStepper(0, stepper1);  // ось 0
  planner.addStepper(1, stepper2);  // ось 1

  // устанавливаем ускорение и скорость
  planner.setAcceleration(200);
  planner.setMaxSpeed(200);
}

byte count = 0;
int32_t path[][2] = {
  {0, 0},
  {100, 150},
  {200, 200},
};

void loop() {
  // здесь происходит движение моторов, вызывать как можно чаще
  planner.tick();

  // вернёт true, если все моторы доехали
  if (planner.ready()) {
    planner.setTarget(path[count]); // загружаем новую точку (начнётся с 0)
    if (++count >= sizeof(path) / 8) count = 0;
  }

  // управляем процессом
  if (Serial.available() > 0) {
    char incoming = Serial.read();
    switch (incoming) {
      case 's': planner.stop(); break;
      case 'b': planner.brake(); break;
      case 'r': planner.resume(); break;
      case 'p': planner.pause(); break;
    }
  }

  // асинхронно вывожу в порт графики
  static uint32_t tmr;
  if (millis() - tmr >= 20) {
    tmr = millis();
    Serial.print(planner.getTarget(0));
    Serial.print(',');
    Serial.print(planner.getTarget(1));
    Serial.print(',');
    Serial.print(stepper1.pos);
    Serial.print(',');
    Serial.println(stepper2.pos);
  }
}

</file>
<file path="lib/GyverStepper/examples/Planner/PlannerDemo/PlannerDemo.ino">
// базовый пример: как создать и запустить планировщик
// при запуске моторы будут отправлены на первую позицию
// при достижении - на вторую. После этого движение прекратится
// открой плоттер и смотри графики

#include "GyverPlanner.h"
// создаём моторы класса Stepper с указанием типа драйвера и пинов. Примеры:
// Stepper<STEPPER2WIRE> stepper(step, dir);                        // драйвер step-dir
// Stepper<STEPPER2WIRE> stepper(step, dir, en);                    // драйвер step-dir + пин enable
// Stepper<STEPPER4WIRE> stepper(pin1, pin2, pin3, pin4);           // драйвер 4 пин
// Stepper<STEPPER4WIRE> stepper(pin1, pin2, pin3, pin4, en);       // драйвер 4 пин + enable
// Stepper<STEPPER4WIRE_HALF> stepper(pin1, pin2, pin3, pin4);      // драйвер 4 пин полушаг
// Stepper<STEPPER4WIRE_HALF> stepper(pin1, pin2, pin3, pin4, en);  // драйвер 4 пин полушаг + enable

// МОТОРЫ ДОЛЖНЫ БЫТЬ С ОДИНАКОВЫМ ТИПОМ ДРАЙВЕРА
// вот они красавцы
Stepper<STEPPER2WIRE> stepper1(2, 5);
Stepper<STEPPER2WIRE> stepper2(3, 6);

// создаём планировщик, указываем в <> тип драйвера КАК У МОТОРОВ
// и количество осей, равное количеству моторов (любое больше 1)
GPlanner<STEPPER2WIRE, 2> planner;

void setup() {
  Serial.begin(115200);
  // добавляем шаговики на оси
  planner.addStepper(0, stepper1);  // ось 0
  planner.addStepper(1, stepper2);  // ось 1

  // устанавливаем ускорение и скорость
  planner.setAcceleration(100);
  planner.setMaxSpeed(300);

  planner.reset();  // сбрасываем все позиции в 0 (они и так в 0 при запуске)

  // массив с целевыми позициями осей, размер массива равен количеству осей
  int target[] = {300, 200};

  // отправляем
  planner.setTarget(target);
}

void loop() {
  // здесь происходит движение моторов, вызывать как можно чаще
  planner.tick();

  // вернёт true, если все моторы доехали
  if (planner.ready()) {
    // загружаем новую точку
    int newTarget[] = {10, 50};
    planner.setTarget(newTarget);
  }

  // асинхронно вывожу в порт графики
  static uint32_t tmr;
  if (millis() - tmr >= 20) {
    tmr = millis();
    Serial.print(stepper1.pos);
    Serial.print(',');
    Serial.println(stepper2.pos);
  }
}

</file>
<file path="lib/GyverStepper/examples/Planner/PlannerHoming/PlannerHoming.ino">
// пример калибровки нуля по концевикам
// концевики на D6 и D7
#define LIMSW_X 6
#define LIMSW_Y 7

#include "GyverPlanner.h"
Stepper<STEPPER2WIRE> stepper1(2, 5);
Stepper<STEPPER2WIRE> stepper2(3, 6);
GPlanner<STEPPER2WIRE, 2> planner;

void setup() {
  // добавляем шаговики на оси
  planner.addStepper(0, stepper1);  // ось 0
  planner.addStepper(1, stepper2);  // ось 1

  // устанавливаем ускорение и скорость
  planner.setAcceleration(100);
  planner.setMaxSpeed(300);

  // пуллапим. Кнопки замыкают на GND
  pinMode(LIMSW_X, INPUT_PULLUP);
  pinMode(LIMSW_Y, INPUT_PULLUP);
}

void loop() {
}

void homing() {
  if (digitalRead(LIMSW_X)) {       // если концевик X не нажат
    planner.setSpeed(0, -10);       // ось Х, -10 шаг/сек
    while (digitalRead(LIMSW_X)) {  // пока кнопка не нажата
      planner.tick();               // крутим
    }
    // кнопка нажалась - покидаем цикл
    planner.brake();                // тормозим, приехали
  }
  
  if (digitalRead(LIMSW_Y)) {       // если концевик Y не нажат
    planner.setSpeed(1, -10);       // ось Y, -10 шаг/сек
    while (digitalRead(LIMSW_Y)) {  // пока кнопка не нажата
      planner.tick();               // крутим
    }
    // кнопка нажалась - покидаем цикл
    planner.brake();                // тормозим, приехали
  }
  planner.reset();    // сбрасываем координаты в 0
}

</file>
<file path="lib/GyverStepper/examples/Planner/PlannerSpeedControl/PlannerSpeedControl.ino">
// крутим мотор. Отправляй в сериал целое число, шаг/сек

#include "GyverPlanner.h"
Stepper<STEPPER2WIRE> stepper1(2, 5);
Stepper<STEPPER2WIRE> stepper2(3, 6);
GPlanner<STEPPER2WIRE, 2> planner;

void setup() {
  Serial.begin(57600);
  // добавляем шаговики на оси
  planner.addStepper(0, stepper1);  // ось 0
  planner.addStepper(1, stepper2);  // ось 1

  Serial.setTimeout(10);
}

void loop() {
  // здесь происходит движение моторов, вызывать как можно чаще
  planner.tick();

  // управляем скоростью
  if (Serial.available() > 0) {
    int val = Serial.parseInt();
    planner.setSpeed(0, val);
  }
}

</file>
<file path="lib/GyverStepper/examples/Planner/PlannerTimerISR/PlannerTimerISR.ino">
// пример с движением моторов в прерывании
// используется Timer1 на atmega328

#include "GyverPlanner.h"
Stepper<STEPPER2WIRE> stepper1(2, 5);
Stepper<STEPPER2WIRE> stepper2(3, 6);
GPlanner<STEPPER2WIRE, 2> planner;

void setup() {
  Serial.begin(115200);
  // добавляем шаговики на оси
  planner.addStepper(0, stepper1);  // ось 0
  planner.addStepper(1, stepper2);  // ось 1

  initTimer();
  startTimer();
}

// прерывание таймера
ISR(TIMER1_COMPA_vect) {
  // здесь происходит движение моторов
  // если мотор должен двигаться (true) - ставим новый период таймеру
  if (planner.tickManual()) setPeriod(planner.getPeriod());
  else stopTimer();
  // если нет - останавливаем таймер
}

int path[][2] = {
  {10, 10},
  {100, 5},
  {200, 200},
  {150, 150},
  {0, 0},
  {0, 50},
};

int count = 0;  // счётчик точек маршрута

void loop() {
  // вернёт true, если все моторы доехали
  if (planner.ready()) {
    if (count < sizeof(path) / 4) {         // ограничиваем на количество точек
      if (planner.setTarget(path[count])) { // загружаем новую точку (начнётся с 0)
        // выполняем дальше код, если есть куда двигаться (получили true)
        // после вызова setTarget обновляется период! можно его юзать
        startTimer();                   // запускаем таймер
        setPeriod(planner.getPeriod()); // устанавливаем период
        count++;
      }
    }
  }

  // асинхронно вывожу в порт графики
  static uint32_t tmr;
  if (millis() - tmr >= 20) {
    tmr = millis();
    Serial.print(stepper1.pos);
    Serial.print(',');
    Serial.println(stepper2.pos);
  }
}

</file>
<file path="lib/GyverStepper/examples/Planner/PlannerTimerISR/timer.ino">
// настроить таймер
void initTimer() {
  TCCR1A = 0;
  // CTC по OCR1A, делитель /64
  TCCR1B = bit(WGM12) | 0b011;
}

// установить период
void setPeriod(uint32_t prd) {
  // один тик таймера - 4 мкс (при 16 МГц клоке)
  OCR1A = (uint32_t)prd >> 2;
}

// запустить и сбросить таймер
void startTimer() {
  TIMSK1 = bit(OCIE1A);
  TCNT1 = 0;
}

// остановить таймер
void stopTimer() {
  TIMSK1 = 0;
  TCNT1 = 0;
}

</file>
<file path="lib/GyverStepper/examples/Planner2/PlannerArray/stepperPlot/stepperPlot.pde">
String port = "COM6";   // имя порта

import processing.serial.*;
Serial myPort;

void setup() {
  size(500, 500);
  myPort = new Serial(this, port, 115200);
  fill(0);
  noStroke();
}

void draw() {  
  if (myPort.available() > 0) {
    String str = myPort.readStringUntil('\n').trim();
    if (str != null) {      
      String[] pos = split(str, ',');
      if (pos.length < 2) return;
      int x = int(pos[0]);
      int y = int(pos[1]);
      fill(10);
      circle(x+10, y+10, 4);
      fill(200, 2);
      rect(0, 0, width, height);
    }
  }
}

</file>
<file path="lib/GyverStepper/examples/Planner2/PlannerArray/PlannerArray.ino">
// пример с записанным в памяти маршрутом
// смотри график

int path[][2] = {
  {100, 250},
  {160, 30},
  {230, 250},
  {60, 100},
  {270, 100},
};

// количество точек (пусть компилятор сам считает)
// как вес всего массива / (2+2) байта
int nodeAmount = sizeof(path) / 4;

#include "GyverPlanner2.h"
Stepper<STEPPER2WIRE> stepper1(2, 5);
Stepper<STEPPER2WIRE> stepper2(3, 6);
GPlanner2<STEPPER2WIRE, 2> planner;

void setup() {
  Serial.begin(115200);
  // добавляем шаговики на оси
  planner.addStepper(0, stepper1);  // ось 0
  planner.addStepper(1, stepper2);  // ось 1

  // устанавливаем ускорение и скорость
  planner.setAcceleration(500);
  planner.setMaxSpeed(500);

  // начальная точка системы должна совпадать с первой точкой маршрута
  planner.setCurrent(path[0]);
  planner.start();
}

int count = 0;  // счётчик точек маршрута
void loop() {
  // здесь происходит движение моторов, вызывать как можно чаще
  planner.tick();

  // если в буфере планировщика есть место
  if (planner.available()) {
    // добавляем точку маршрута и является ли она точкой остановки (0 - нет)
    planner.addTarget(path[count], 0);
    if (++count >= sizeof(path) / 4) count = 0; // закольцевать
  }

  // асинхронно вывожу в порт графики
  static uint32_t tmr;
  if (millis() - tmr >= 20) {
    tmr = millis();
    Serial.print(stepper1.pos);
    Serial.print(',');
    Serial.println(stepper2.pos);
  }
}

</file>
<file path="lib/GyverStepper/examples/Planner2/PlannerCircle/stepperPlot/stepperPlot.pde">
String port = "COM6";   // имя порта

import processing.serial.*;
Serial myPort;

void setup() {
  size(500, 500);
  myPort = new Serial(this, port, 115200);
  fill(0);
  noStroke();
}

void draw() {  
  if (myPort.available() > 0) {
    String str = myPort.readStringUntil('\n').trim();
    if (str != null) {      
      String[] pos = split(str, ',');
      if (pos.length < 2) return;
      int x = int(pos[0]);
      int y = int(pos[1]);
      fill(10);
      circle(x+10, y+10, 4);
      fill(200, 2);
      rect(0, 0, width, height);
    }
  }
}

</file>
<file path="lib/GyverStepper/examples/Planner2/PlannerCircle/PlannerCircle.ino">
// пример с записанным в памяти маршрутом окружности
// работу можно посмотреть в плоттере, а лучше в приложенном stepperPlot для Processing

const int pointAm = 30;     // количество точек в круге
int radius = 100;           // радиус круга
int32_t path[pointAm + 1 + 1][2];     // буфер круга
// +1 на стартовую точку +1 на замыкание круга

#include "GyverPlanner2.h"
Stepper<STEPPER2WIRE> stepper1(2, 5);
Stepper<STEPPER2WIRE> stepper2(3, 6);
GPlanner2<STEPPER2WIRE, 2> planner;

void setup() {
  Serial.begin(115200);
  // добавляем шаговики на оси
  planner.addStepper(0, stepper1);  // ось 0
  planner.addStepper(1, stepper2);  // ось 1

  // устанавливаем ускорение и скорость
  planner.setAcceleration(500);
  planner.setMaxSpeed(500);
  
  // начальная точка системы должна совпадать с первой точкой маршрута
  planner.setCurrent(path[0]);

  // заполняем буфер
  for (int i = 0; i <= pointAm; i++) {
    path[i + 1][0] = radius + radius * cos(TWO_PI * i / pointAm);
    path[i + 1][1] = radius + radius * sin(TWO_PI * i / pointAm);
  }
  // 0 - координата 0,0
  // 1 - первая координата круга
  // итд
  
  planner.start();
}

int count = 0;  // счётчик точек маршрута
void loop() {
  // здесь происходит движение моторов, вызывать как можно чаще
  planner.tick();

  // если в буфере планировщика есть место
  if (planner.available()) {
    // добавляем точку маршрута и является ли она точкой остановки (0 - нет)
    planner.addTarget(path[count], 0);
    if (++count >= sizeof(path) / 8) count = 0; // закольцевать
  }

  // асинхронно вывожу в порт графики
  static uint32_t tmr;
  if (millis() - tmr >= 20) {
    tmr = millis();
    Serial.print(stepper1.pos);
    Serial.print(',');
    Serial.println(stepper2.pos);
  }
}

</file>
<file path="lib/GyverStepper/examples/Planner2/PlannerCircleISR/stepperPlot/stepperPlot.pde">
String port = "COM6";   // имя порта

import processing.serial.*;
Serial myPort;

void setup() {
  size(500, 500);
  myPort = new Serial(this, port, 115200);
  fill(0);
  noStroke();
}

void draw() {  
  if (myPort.available() > 0) {
    String str = myPort.readStringUntil('\n').trim();
    if (str != null) {      
      String[] pos = split(str, ',');
      if (pos.length < 2) return;
      int x = int(pos[0]);
      int y = int(pos[1]);
      fill(10);
      circle(x+10, y+10, 4);
      fill(200, 2);
      rect(0, 0, width, height);
    }
  }
}

</file>
<file path="lib/GyverStepper/examples/Planner2/PlannerCircleISR/PlannerCircleISR.ino">
// тож самое, но тик по таймеру
// пример с записанным в памяти маршрутом окружности
// работу можно посмотреть в плоттере, а лучше в приложенном stepperPlot для Processing

const int pointAm = 30;     // количество точек в круге
int radius = 100;           // радиус круга
int32_t path[pointAm + 1 + 1][2];     // буфер круга
// +1 на стартовую точку +1 на замыкание круга

#include "GyverPlanner2.h"
Stepper<STEPPER2WIRE> stepper1(2, 5);
Stepper<STEPPER2WIRE> stepper2(3, 6);
GPlanner2<STEPPER2WIRE, 2> planner;

void setup() {
  Serial.begin(115200);
  // добавляем шаговики на оси
  planner.addStepper(0, stepper1);  // ось 0
  planner.addStepper(1, stepper2);  // ось 1

  // устанавливаем ускорение и скорость
  planner.setAcceleration(500);
  planner.setMaxSpeed(500);

  // начальная точка системы должна совпадать с первой точкой маршрута
  planner.setCurrent(path[0]);

  // заполняем буфер
  for (int i = 0; i <= pointAm; i++) {
    path[i + 1][0] = radius + radius * cos(TWO_PI * i / pointAm);
    path[i + 1][1] = radius + radius * sin(TWO_PI * i / pointAm);
  }
  // 0 - координата 0,0
  // 1 - первая координата круга
  // итд

  // заводим всё
  planner.start();
  initTimer();  
}

// прерывание таймера
ISR(TIMER1_COMPA_vect) {
  // здесь происходит движение моторов
  // если мотор должен двигаться (true) - ставим новый период таймеру
  if (planner.tickManual()) setPeriod(planner.getPeriod());
  else stopTimer();
  // если нет - останавливаем таймер
}

int count = 0;  // счётчик точек маршрута
void loop() {
  // вручную проверяем буфер. Если начался новый отрезок движения
  if (planner.checkBuffer()) {
    startTimer();                     // запускаем таймер
    setPeriod(planner.getPeriod());   // устанавливаем новый период
  }
  
  // если в буфере планировщика есть место
  if (planner.available()) {
    // добавляем точку маршрута и является ли она точкой остановки (0 - нет)
    planner.addTarget(path[count], 0);
    if (++count >= sizeof(path) / 8) count = 0; // закольцевать
  }

  // асинхронно вывожу в порт графики
  static uint32_t tmr;
  if (millis() - tmr >= 20) {
    tmr = millis();
    Serial.print(stepper1.pos);
    Serial.print(',');
    Serial.println(stepper2.pos);
  }
}

</file>
<file path="lib/GyverStepper/examples/Planner2/PlannerCircleISR/timer.ino">
// настроить таймер
void initTimer() {
  TCCR1A = 0;
  // CTC по OCR1A, делитель /64
  TCCR1B = bit(WGM12) | 0b011;
}

// установить период
void setPeriod(uint32_t prd) {
  // один тик таймера - 4 мкс (при 16 МГц клоке)
  OCR1A = (uint32_t)prd >> 2;
}

// запустить и сбросить таймер
void startTimer() {
  TIMSK1 = bit(OCIE1A);
  TCNT1 = 0;
}

// остановить таймер
void stopTimer() {
  TIMSK1 = 0;
  TCNT1 = 0;
}

</file>
<file path="lib/GyverStepper/examples/Stepper/accelDeccelButton/accelDeccelButton.ino">
// начинаем плавный разгон при удержании кнопки. При отпускании тормозим

//#define SMOOTH_ALGORITHM
#include <GyverStepper.h>
//GStepper<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper<STEPPER2WIRE> stepper(2048, 2, 5);


void setup() {
  Serial.begin(115200);
  pinMode(A0, INPUT_PULLUP);  // кнопка на A0 и GND
  stepper.enable();
  stepper.autoPower(true);

  // установка ускорения в шагах/сек/сек
  stepper.setAcceleration(1200);
  stepper.setRunMode(KEEP_SPEED);
}

bool btnState = false;
void loop() {
  stepper.tick();

  // кнопка нажата
  if (!digitalRead(A0) && !btnState) {
    btnState = true;
    stepper.setSpeed(3000, SMOOTH);
  }

  // кнопка отпущена
  if (digitalRead(A0) && btnState) {
    btnState = false;
    stepper.stop();
  }
}

</file>
<file path="lib/GyverStepper/examples/Stepper/demo/demo.ino">
// демо - основные возможности библиотеки

#include <GyverStepper.h>
GStepper<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);

// мотор с драйвером ULN2003 подключается по порядку пинов, но крайние нужно поменять местами
// то есть у меня подключено D2-IN1, D3-IN2, D4-IN3, D5-IN4, но в программе поменял 5 и 2

// создание объекта
// steps - шагов на один оборот вала (для расчётов с градусами)
// step, dir, pin1, pin2, pin3, pin4 - любые GPIO
// en - пин отключения драйвера, любой GPIO
//GStepper<STEPPER2WIRE> stepper(steps, step, dir);                   // драйвер step-dir
//GStepper<STEPPER2WIRE> stepper(steps, step, dir, en);               // драйвер step-dir + пин enable
//GStepper<STEPPER4WIRE> stepper(steps, pin1, pin2, pin3, pin4);      // драйвер 4 пин
//GStepper<STEPPER4WIRE> stepper(steps, pin1, pin2, pin3, pin4, en);  // драйвер 4 пин + enable
//GStepper<STEPPER4WIRE_HALF> stepper(steps, pin1, pin2, pin3, pin4);     // драйвер 4 пин полушаг
//GStepper<STEPPER4WIRE_HALF> stepper(steps, pin1, pin2, pin3, pin4, en); // драйвер 4 пин полушаг + enable

void setup() {
  Serial.begin(115200);
  // режим поддержания скорости
  stepper.setRunMode(KEEP_SPEED);

  // можно установить скорость
  stepper.setSpeed(120);    // в шагах/сек
  stepper.setSpeedDeg(80);  // в градусах/сек

  // режим следования к целевй позиции
  stepper.setRunMode(FOLLOW_POS);

  // можно установить позицию
  stepper.setTarget(-2024);    // в шагах
  stepper.setTargetDeg(-360);  // в градусах

  // установка макс. скорости в градусах/сек
  stepper.setMaxSpeedDeg(400);
  
  // установка макс. скорости в шагах/сек
  stepper.setMaxSpeed(400);

  // установка ускорения в градусах/сек/сек
  stepper.setAccelerationDeg(300);

  // установка ускорения в шагах/сек/сек
  stepper.setAcceleration(300);

  // отключать мотор при достижении цели
  stepper.autoPower(true);

  // включить мотор (если указан пин en)
  stepper.enable();
}

void loop() {
  // просто крутим туды-сюды
  if (!stepper.tick()) {
    static bool dir;
    dir = !dir;
    stepper.setTarget(dir ? -1024 : 1024);
  }
}

</file>
<file path="lib/GyverStepper/examples/Stepper/endSwitch/endSwitch.ino">
// пример с концевиком
#include <GyverStepper.h>
//GStepper<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper<STEPPER2WIRE> stepper(2048, 2, 5);

void setup() {
  // наша задача - при запуске крутить мотор в сторону до нажатия на кнопку
  pinMode(12, INPUT_PULLUP);  // кнопка на D12 и GND
  
  stepper.setRunMode(KEEP_SPEED);
  stepper.setSpeedDeg(-10);   // медленно крутимся НАЗАД

  // пока кнопка не нажата
  while(digitalRead(12)) {    
    stepper.tick();
	// yield();	// для esp8266
  }
  // вот тут кнопка нажата, сразу вырубаем мотор.
  // Текущее положение также сбрасывается в 0
  stepper.reset();

  // дальше например врубаем FOLLOW_POS
  stepper.setRunMode(FOLLOW_POS);
}

void loop() {
  // и качаемся в 20 шагах от кнопки и до 300
  static bool dir;
  if (!stepper.tick()) {
    dir = !dir;
    stepper.setTarget(dir ? 20 : 300);
  }
}

</file>
<file path="lib/GyverStepper/examples/Stepper/externalDriver/externalDriver.ino">
// пример с использованием "внешнего" драйвера, который может быть
// подключен к расширителю портов.

// в качестве примера использую digitalWrite и родные пины
#define PIN_A 2
#define PIN_B 4
#define PIN_C 3
#define PIN_D 5

#include <GyverStepper.h>
GStepper<STEPPER4WIRE, STEPPER_VIRTUAL> stepper(2048);

void setup() {
  Serial.begin(9600);
  // выходы
  pinMode(PIN_A, 1);
  pinMode(PIN_B, 1);
  pinMode(PIN_C, 1);
  pinMode(PIN_D, 1);
  
  stepper.setRunMode(KEEP_SPEED); // режим поддержания скорости
  stepper.setSpeedDeg(100);       // в градусах/сек
  stepper.setAcceleration(500);

  // подключить свою функцию-обработчик шага
  stepper.attachStep(step);
  
  // подключить свою функцию-обработчик для управления питанием
  stepper.attachPower(pwr);

  stepper.autoPower(1);   // включаем авто выкл питания
}

// наша функция-обработчик. Будет вызываться на каждом шагу
// у STEPPER4WIRE val содержит состояния обмоток как 0bABCD
// у STEPPER2WIRE val содержит 0 или 1 как DIR, STEP нужно дёрнуть самому
void step(byte val) {
  // дёргаем вручную пины
  digitalWrite(PIN_D, val & 1);
  val >>= 1;
  digitalWrite(PIN_C, val & 1);
  val >>= 1;
  digitalWrite(PIN_B, val & 1);
  val >>= 1;
  digitalWrite(PIN_A, val & 1);
}

void pwr(bool val) {
  // тут val будет 0 или 1 в зависимости от питания. Подавай на EN
  Serial.println(val);
}

void loop() {
  stepper.tick();

  // разгон и остановка каждые 3 секунды
  static uint32_t tmr;
  if (millis() - tmr >= 3000) {
    tmr = millis();
    static bool dir = 1;
    dir = !dir;
    if (!dir) stepper.stop();
    else stepper.setSpeedDeg(100);
  }
}

</file>
<file path="lib/GyverStepper/examples/Stepper/multiStepper/multiStepper.ino">
// крутим мотор туда-сюда плавно с ускорением

#include "GyverStepper.h"
// подключим три мотора
// у первого и второго управление EN не подключаем
GStepper<STEPPER2WIRE> stepper1(100, 2, 3);
GStepper<STEPPER2WIRE> stepper2(100, 4, 5);
GStepper<STEPPER2WIRE> stepper3(100, 6, 7, 8);

void setup() {
  // мотор 1 просто вращается
  stepper1.setRunMode(KEEP_SPEED);
  stepper1.setSpeed(300);

  // мотор 2 будет делать sweep по проверке tick
  stepper2.setRunMode(FOLLOW_POS);
  stepper2.setMaxSpeed(1000);
  stepper2.setAcceleration(300);

  // мотор 3 будет перемещаться на случайную позицию
  stepper3.setRunMode(FOLLOW_POS);
  stepper3.setMaxSpeed(1000);
  stepper3.setAcceleration(300);
  stepper3.autoPower(true);
  stepper3.enable();
}

void loop() {
  // первый мотор
  stepper1.tick();
  
  // второй крутим туды-сюды (-1000, 1000)
  if (!stepper2.tick()) {
    static bool dir;
    dir = !dir;
    stepper2.setTarget(dir ? -1000 : 1000);
  }

  // третий по таймеру
  // будет отключаться при остановке
  stepper3.tick();
  static uint32_t tmr;
  if (millis() - tmr > 5000) {   // каждые 5 секунд
    tmr = millis();
    stepper3.setTarget(random(0, 2000));  // рандом 0-2000
  }
}

</file>
<file path="lib/GyverStepper/examples/Stepper/potPos/potPos.ino">
// установка позиции потенциометром

#include <GyverStepper.h>
//GStepper<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper<STEPPER2WIRE> stepper(2048, 2, 5);

void setup() {
  Serial.begin(115200);
  stepper.setRunMode(FOLLOW_POS);   // режим следования к целевй позиции
  stepper.setMaxSpeed(400);         // установка макс. скорости в шагах/сек
  stepper.setAcceleration(500);     // установка ускорения в шагах/сек/сек

  // пусть драйвер выключается при достижении позиции
  stepper.autoPower(true);
}

void loop() {
  stepper.tick();

  // сделаем таймер на 20 мс
  // будем опрашивать потенциометр и строить графики
  static uint32_t tmr2;
  if (millis() - tmr2 > 20) {
    tmr2 = millis();
    static float val;
    // потенциометр на A0
    // фильтруем, иначе мотор будет трястись
    val += (analogRead(0) - val) * 0.08;

    stepper.setTarget(val);     // ставим новую позицию
    Serial.print(stepper.getTarget());
    Serial.print(',');
    Serial.println(stepper.getCurrent());
  }
}

</file>
<file path="lib/GyverStepper/examples/Stepper/potSpeed/potSpeed.ino">
// установка скорости потенциометром

#include <GyverStepper.h>
//GStepper<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper<STEPPER2WIRE> stepper(2048, 2, 5);

void setup() {
  stepper.setRunMode(KEEP_SPEED); // режим поддержания скорости
  stepper.setSpeedDeg(50);        // в градусах/сек
}

void loop() {
  stepper.tick();

  // сделаем таймер на 50 мс и будем опрашивать потенциометр
  // менять скорость чаще нет смысла
  static uint32_t tmr2;
  if (millis() - tmr2 > 50) {
    tmr2 = millis();

    // ставим новую скорость (-512.. 512 шагов в секунду)
    // будет крутиться в разные стороны
    stepper.setSpeed(512 - analogRead(0));
  }
}

</file>
<file path="lib/GyverStepper/examples/Stepper/smoothAlgorithm/smoothAlgorithm.ino">
// используем более плавный алгоритм движения. Макс. скорость ограничена до
// 7000 шаг/сек, алгоритм использует много процессорного времени!

// перед подключением библиотеки дефайним
#define SMOOTH_ALGORITHM

#include <GyverStepper.h>
//GStepper<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper<STEPPER2WIRE> stepper(2048, 2, 5);

void setup() {
  Serial.begin(115200);

  // режим следования к целевй позиции
  stepper.setRunMode(FOLLOW_POS);

  // установка макс. скорости в шагах/сек
  stepper.setMaxSpeed(400);

  // установка ускорения в шагах/сек/сек
  stepper.setAcceleration(500);
}

void loop() {
  // просто крутим туды-сюды
  if (!stepper.tick()) {
    static bool dir;
    dir = !dir;
    stepper.setTarget(dir ? -400 : 400);
  }
}

</file>
<file path="lib/GyverStepper/examples/Stepper/speed/speed.ino">
// крутимся с заданной скоростью

#include <GyverStepper.h>
//GStepper<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper<STEPPER2WIRE> stepper(2048, 2, 5);

void setup() {
  stepper.setRunMode(KEEP_SPEED); // режим поддержания скорости
  stepper.setSpeedDeg(50);        // в градусах/сек
}

void loop() {
  stepper.tick();
}

</file>
<file path="lib/GyverStepper/examples/Stepper/speedSerialControl/speedSerialControl.ino">
// управляем скоростью из СОМ порта
// отправь q для тормоза
// отправь w для плавной остановки
// отправь e для скорости 5 град/сек
// отправь r для скорости 100 град/сек

#include <GyverStepper.h>
//GStepper<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper<STEPPER2WIRE> stepper(2048, 2, 5);

void setup() {
  Serial.begin(9600);
  stepper.setRunMode(KEEP_SPEED); // режим поддержания скорости
  stepper.setSpeedDeg(5);         // в градусах/сек
}

void loop() {
  stepper.tick();
  if (Serial.available()) {
    char ch = Serial.read();
    if (ch == 'q') stepper.brake();
    if (ch == 'w') stepper.stop();
    if (ch == 'e') stepper.setSpeedDeg(5);
    if (ch == 'r') stepper.setSpeedDeg(100);
  }
}

</file>
<file path="lib/GyverStepper/examples/Stepper/stop/stop.ino">
// пример работы stop()
// на графике будет видно, как сместилась установка и мотор к ней затормозил
#include <GyverStepper.h>
//GStepper<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper<STEPPER2WIRE> stepper(2048, 2, 5);

void setup() {
  Serial.begin(115200);
  stepper.setMaxSpeed(400);
  stepper.setAcceleration(300);
  stepper.setRunMode(FOLLOW_POS);

  // отправляем мотор подальше
  stepper.setTarget(-2024);
}

void loop() {
  stepper.tick();

  // плавная остановка через 3 секунды
  static uint32_t tmr;
  static bool flag = false;
  if (!flag && millis() > 3000) {
    stepper.stop();
    flag = true;
  }

  // график установки и текущей позиции
  static uint32_t tmr2;
  if (millis() - tmr2 > 20) {
    tmr2 = millis();
    Serial.print(stepper.getTarget());
    Serial.print(',');
    Serial.println(stepper.getCurrent());
  }
}

</file>
<file path="lib/GyverStepper/examples/Stepper/sweep/sweep.ino">
// крутим мотор туда-сюда плавно с ускорением

#include <GyverStepper.h>
//GStepper<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper<STEPPER2WIRE> stepper(2048, 2, 5);

void setup() {
  Serial.begin(115200);

  // режим следования к целевй позиции
  stepper.setRunMode(FOLLOW_POS);

  // установка макс. скорости в шагах/сек
  stepper.setMaxSpeed(400);

  // установка ускорения в шагах/сек/сек
  stepper.setAcceleration(500);
}

void loop() {
  // просто крутим туды-сюды
  if (!stepper.tick()) {
    static bool dir;
    dir = !dir;
    stepper.setTarget(dir ? -400 : 400);
  }

  // график положения
  static uint32_t tmr2;
  if (millis() - tmr2 > 20) {
    tmr2 = millis();
    Serial.println(stepper.getCurrent());
  }
}

</file>
<file path="lib/GyverStepper/examples/Stepper/timerISR/timerISR.ino">
// пример с тиком по прерыванию таймера
// используется GyverTimers

#include <GyverStepper.h>
//GStepper<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper<STEPPER2WIRE> stepper(2048, 2, 5);

#include <GyverTimers.h>

void setup() {
  Serial.begin(115200);

  // режим следования к целевй позиции
  stepper.setRunMode(FOLLOW_POS);

  // установка макс. скорости в шагах/сек
  stepper.setMaxSpeed(400);

  // установка ускорения в шагах/сек/сек
  stepper.setAcceleration(500);

  // настраиваем прерывания с периодом, при котором 
  // система сможет обеспечить максимальную скорость мотора.
  // Для большей плавности лучше лучше взять период чуть меньше, например в два раза
  Timer2.setPeriod(stepper.getMinPeriod() / 2);

  // взводим прерывание
  Timer2.enableISR();
}

// обработчик
ISR(TIMER2_A) {
  stepper.tick(); // тикаем тут
}

void loop() {
  // просто крутим туды-сюды
  if (!stepper.tick()) {  // тут всё равно вызываем для смены направления
    static bool dir;
    dir = !dir;
    stepper.setTarget(dir ? -400 : 400);
  }

  // график положения
  Serial.println(stepper.getCurrent());

  // задержка, чтобы показать работу степпера в прерывании  
  delay(100);
}

</file>
<file path="lib/GyverStepper/examples/Stepper2/homing/homing.ino">
// пример калибровки нуля по концевикам
// концевик на D6
#define LIMSW_X 6

#include "GyverStepper2.h"
//GStepper2<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper2<STEPPER2WIRE> stepper(2048, 2, 5);

void setup() {
  // пуллапим. Кнопки замыкают на GND
  pinMode(LIMSW_X, INPUT_PULLUP);
}

void loop() {
}

void homing() {
  if (digitalRead(LIMSW_X)) {       // если концевик X не нажат
    stepper.setSpeed(-10);       // ось Х, -10 шаг/сек
    while (digitalRead(LIMSW_X)) {  // пока кнопка не нажата
      stepper.tick();               // крутим
    }
    // кнопка нажалась - покидаем цикл
    stepper.brake();                // тормозим, приехали
  }
  stepper.reset();    // сбрасываем координаты в 0
}

</file>
<file path="lib/GyverStepper/examples/Stepper2/SpeedControl/SpeedControl.ino">
// крутим мотор. Отправляй в сериал целое число, шаг/сек

#include "GyverStepper2.h"
//GStepper2<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper2<STEPPER2WIRE> stepper(2048, 2, 5);

void setup() {
  Serial.begin(9600);
  Serial.setTimeout(10);
}

void loop() {
  // здесь происходит движение моторов, вызывать как можно чаще
  stepper.tick();

  // управляем скоростью
  if (Serial.available() > 0) {
    int val = Serial.parseInt();
    stepper.setSpeed(val);
  }

  static uint32_t tmr;
  if (millis() - tmr >= 30) {
    tmr = millis();
    Serial.println(stepper.pos);
  }
}

</file>
<file path="lib/GyverStepper/examples/Stepper2/StepperControl/StepperControl.ino">
// здесь у нас моторы движутся по трём точкам траектории
// можно открыть плоттер, наблюать за этим и отправлять команды:
// s - стоп
// b - тормоз
// p - пауза
// r - продолжить
//#define GS_NO_ACCEL
#include "GyverStepper2.h"
//GStepper2<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper2<STEPPER2WIRE> stepper(2048, 2, 5);

void setup() {
  Serial.begin(9600);

  // устанавливаем ускорение и скорость
  stepper.setAcceleration(200);
  stepper.setMaxSpeed(100);
  stepper.setTarget(0);
  //stepper.setSpeed(100);
}

byte count = 0;
int16_t path[] = {0, 200, 100};

void loop() {
  // здесь происходит движение мотора, вызывать как можно чаще
  stepper.tick();

  // вернёт true, если все моторы доехали
  if (stepper.ready()) {
    stepper.setTarget(path[count]); // загружаем новую точку (начнётся с 0)
    if (++count >= sizeof(path) / 2) count = 0;
  }

  // управляем процессом
  if (Serial.available() > 0) {
    char incoming = Serial.read();
    switch (incoming) {
      case 's': stepper.stop(); break;
      case 'b': stepper.brake(); break;
      case 'r': stepper.resume(); break;
      case 'p': stepper.pause(); break;
    }
  }

  // асинхронно вывожу в порт графики
  static uint32_t tmr;
  if (millis() - tmr >= 20) {
    tmr = millis();
    Serial.print(stepper.getTarget());
    Serial.print(',');
    Serial.println(stepper.pos);
  }
}

</file>
<file path="lib/GyverStepper/examples/Stepper2/sweep/sweep.ino">
// крутим туда сюда, тикаем в loop

#include "GyverStepper2.h"
//GStepper2<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper2<STEPPER2WIRE> stepper(2048, 2, 5);

void setup() {
  Serial.begin(9600);
  //stepper.enable();
  stepper.setMaxSpeed(100);     // скорость движения к цели
  stepper.setAcceleration(200); // ускорение
  stepper.setTarget(300);       // цель
}

bool dir = 1;
void loop() {
  stepper.tick();   // мотор асинхронно крутится тут

  // если приехали
  if (stepper.ready()) {
    dir = !dir;   // разворачиваем
    stepper.setTarget(dir * 300); // едем в другую сторону
  }

  // асинхронный вывод в порт
  static uint32_t tmr;
  if (millis() - tmr >= 30) {
    tmr = millis();
    Serial.println(stepper.pos);
  }
}

</file>
<file path="lib/GyverStepper/examples/Stepper2/sweep_FAST_PROFILE/sweep_FAST_PROFILE.ino">
// крутим туда сюда, тикаем в loop

// включаем быстрый профиль, 10 участков
#define GS_FAST_PROFILE 10
#include "GyverStepper2.h"
//GStepper2<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper2<STEPPER2WIRE> stepper(2048, 2, 5);

uint32_t tar = 60000;
bool dir = 1;

void setup() {
  Serial.begin(9600);

  //stepper.enable();
  stepper.setMaxSpeed(30000);     // скорость движения к цели
  stepper.setAcceleration(30000); // ускорение

  stepper.setTarget(tar);       // цель
}

void loop() {
  while (1) {
    stepper.tick();   // мотор асинхронно крутится тут

    // если приехали
    if (stepper.ready()) {
      dir = !dir;   // разворачиваем
      stepper.setTarget(dir * tar); // едем в другую сторону
    }

    // асинхронный вывод в порт
    static uint32_t tmr;
    if (millis() - tmr >= 30) {
      tmr = millis();
      Serial.println(stepper.pos);
    }
  }
}

</file>
<file path="lib/GyverStepper/examples/Stepper2/sweepISR/sweepISR.ino">
// крутим туда сюда, прерывание таймера

#include "GyverStepper2.h"
//GStepper2<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper2<STEPPER2WIRE> stepper(2048, 2, 5);

void setup() {
  Serial.begin(9600);
  initTimer();
  //stepper.enable();
  stepper.setMaxSpeed(100);     // скорость движения к цели
  stepper.setAcceleration(200); // ускорение
  stepper.setTarget(300);       // цель
  setPeriod(stepper.getPeriod());
  startTimer();
}

// прерывание таймера
ISR(TIMER1_COMPA_vect) {
  // здесь происходит движение мотора
  // если мотор должен двигаться (true) - ставим новый период таймеру
  if (stepper.tickManual()) setPeriod(stepper.getPeriod());
  else stopTimer();
  // если нет - останавливаем таймер
}

bool dir = 1;
void loop() {
  // если приехали
  if (stepper.ready()) {
    dir = !dir;   // разворачиваем
    stepper.setTarget(dir * 300); // едем в другую сторону
    setPeriod(stepper.getPeriod());
    startTimer();
  }

  // асинхронный вывод в порт
  static uint32_t tmr;
  if (millis() - tmr >= 30) {
    tmr = millis();
    Serial.println(stepper.pos);
  }
}

</file>
<file path="lib/GyverStepper/examples/Stepper2/sweepISR/timer.ino">
// настроить таймер
void initTimer() {
  TCCR1A = 0;
  // CTC по OCR1A, делитель /64
  TCCR1B = bit(WGM12) | 0b011;
}

// установить период
void setPeriod(uint32_t prd) {
  // один тик таймера - 4 мкс (при 16 МГц клоке)
  OCR1A = (uint32_t)prd >> 2;
}

// запустить и сбросить таймер
void startTimer() {
  TIMSK1 = bit(OCIE1A);
  TCNT1 = 0;
}

// остановить таймер
void stopTimer() {
  TIMSK1 = 0;
  TCNT1 = 0;
}

</file>
<file path="lib/SerialCommand/examples/SerialCommandExample/SerialCommandExample.pde">
// Demo Code for SerialCommand Library
// Steven Cogswell
// May 2011

#include <SerialCommand.h>

#define arduinoLED 13   // Arduino LED on board

SerialCommand sCmd;     // The demo SerialCommand object

void setup() {
  pinMode(arduinoLED, OUTPUT);      // Configure the onboard LED for output
  digitalWrite(arduinoLED, LOW);    // default to LED off

  Serial.begin(9600);

  // Setup callbacks for SerialCommand commands
  sCmd.addCommand("ON",    LED_on);          // Turns LED on
  sCmd.addCommand("OFF",   LED_off);         // Turns LED off
  sCmd.addCommand("HELLO", sayHello);        // Echos the string argument back
  sCmd.addCommand("P",     processCommand);  // Converts two arguments to integers and echos them back
  sCmd.setDefaultHandler(unrecognized);      // Handler for command that isn't matched  (says "What?")
  Serial.println("Ready");
}

void loop() {
  sCmd.readSerial();     // We don't do much, just process serial commands
}


void LED_on() {
  Serial.println("LED on");
  digitalWrite(arduinoLED, HIGH);
}

void LED_off() {
  Serial.println("LED off");
  digitalWrite(arduinoLED, LOW);
}

void sayHello() {
  char *arg;
  arg = sCmd.next();    // Get the next argument from the SerialCommand object buffer
  if (arg != NULL) {    // As long as it existed, take it
    Serial.print("Hello ");
    Serial.println(arg);
  }
  else {
    Serial.println("Hello, whoever you are");
  }
}


void processCommand() {
  int aNumber;
  char *arg;

  Serial.println("We're in processCommand");
  arg = sCmd.next();
  if (arg != NULL) {
    aNumber = atoi(arg);    // Converts a char string to an integer
    Serial.print("First argument was: ");
    Serial.println(aNumber);
  }
  else {
    Serial.println("No arguments");
  }

  arg = sCmd.next();
  if (arg != NULL) {
    aNumber = atol(arg);
    Serial.print("Second argument was: ");
    Serial.println(aNumber);
  }
  else {
    Serial.println("No second argument");
  }
}

// This gets set as the default handler, and gets called when no other command matches.
void unrecognized(const char *command) {
  Serial.println("What?");
}

</file>
<file path="lib/SerialCommand/keywords.txt">
#######################################
# Datatypes (KEYWORD1)
#######################################

SerialCommand	KEYWORD1

#######################################
# Methods and Functions (KEYWORD2)
#######################################

addCommand	KEYWORD2
setDefaultHandler	KEYWORD2
readSerial	KEYWORD2
clearBuffer	KEYWORD2
next	KEYWORD2

#######################################
# Instances (KEYWORD2)
#######################################

#######################################
# Constants (LITERAL1)
####################################### 

</file>
<file path="lib/SerialCommand/library.json">
{
  "name": "SerialCommand",
  "keywords": "serial, communication, protocol",
  "description": "A Wiring/Arduino library to tokenize and parse commands received over a serial port.",
  "repository":
  {
    "type": "git",
    "url": "https://github.com/kroimon/Arduino-SerialCommand.git"
  },
  "frameworks": "arduino",
  "platforms": "atmelavr"
}

</file>
<file path="lib/SerialCommand/readme.md">
SerialCommand
=============
A Wiring/Arduino library to tokenize and parse commands received over a serial port. 

The original version of this library was written by [Steven Cogswell](http://husks.wordpress.com) (published May 23, 2011 in his blog post ["A Minimal Arduino Library for Processing Serial Commands"](http://husks.wordpress.com/2011/05/23/a-minimal-arduino-library-for-processing-serial-commands/)).

This is a heavily modified version with smaller footprint and a cleaned up code by Stefan Rado.

</file>
<file path="lib/SerialCommand/SerialCommand.cpp">
/**
 * SerialCommand - A Wiring/Arduino library to tokenize and parse commands
 * received over a serial port.
 * 
 * Copyright (C) 2012 Stefan Rado
 * Copyright (C) 2011 Steven Cogswell <steven.cogswell@gmail.com>
 *                    http://husks.wordpress.com
 * 
 * Version 20120522
 * 
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this library.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "SerialCommand.h"

/**
 * Constructor makes sure some things are set.
 */
SerialCommand::SerialCommand()
  : commandList(NULL),
    commandCount(0),
    defaultHandler(NULL),
    term('\n'),           // default terminator for commands, newline character
    last(NULL)
{
  strcpy(delim, " "); // strtok_r needs a null-terminated string
  clearBuffer();
}

/**
 * Adds a "command" and a handler function to the list of available commands.
 * This is used for matching a found token in the buffer, and gives the pointer
 * to the handler function to deal with it.
 */
void SerialCommand::addCommand(const char *command, void (*function)()) {
  #ifdef SERIALCOMMAND_DEBUG
    Serial.print("Adding command (");
    Serial.print(commandCount);
    Serial.print("): ");
    Serial.println(command);
  #endif

  commandList = (SerialCommandCallback *) realloc(commandList, (commandCount + 1) * sizeof(SerialCommandCallback));
  strncpy(commandList[commandCount].command, command, SERIALCOMMAND_MAXCOMMANDLENGTH);
  commandList[commandCount].function = function;
  commandCount++;
}

/**
 * This sets up a handler to be called in the event that the receveived command string
 * isn't in the list of commands.
 */
void SerialCommand::setDefaultHandler(void (*function)(const char *)) {
  defaultHandler = function;
}


/**
 * This checks the Serial stream for characters, and assembles them into a buffer.
 * When the terminator character (default '\n') is seen, it starts parsing the
 * buffer for a prefix command, and calls handlers setup by addCommand() member
 */
void SerialCommand::readSerial() {
  while (Serial.available() > 0) {
    char inChar = Serial.read();   // Read single available character, there may be more waiting
    #ifdef SERIALCOMMAND_DEBUG
      Serial.print(inChar);   // Echo back to serial stream
    #endif

    if (inChar == term) {     // Check for the terminator (default '\r') meaning end of command
      #ifdef SERIALCOMMAND_DEBUG
        Serial.print("Received: ");
        Serial.println(buffer);
      #endif

      char *command = strtok_r(buffer, delim, &last);   // Search for command at start of buffer
      if (command != NULL) {
        boolean matched = false;
        for (int i = 0; i < commandCount; i++) {
          #ifdef SERIALCOMMAND_DEBUG
            Serial.print("Comparing [");
            Serial.print(command);
            Serial.print("] to [");
            Serial.print(commandList[i].command);
            Serial.println("]");
          #endif

          // Compare the found command against the list of known commands for a match
          if (strncmp(command, commandList[i].command, SERIALCOMMAND_MAXCOMMANDLENGTH) == 0) {
            #ifdef SERIALCOMMAND_DEBUG
              Serial.print("Matched Command: ");
              Serial.println(command);
            #endif

            // Execute the stored handler function for the command
            (*commandList[i].function)();
            matched = true;
            break;
          }
        }
        if (!matched && (defaultHandler != NULL)) {
          (*defaultHandler)(command);
        }
      }
      clearBuffer();
    }
    else if (isprint(inChar)) {     // Only printable characters into the buffer
      if (bufPos < SERIALCOMMAND_BUFFER) {
        buffer[bufPos++] = inChar;  // Put character into buffer
        buffer[bufPos] = '\0';      // Null terminate
      } else {
        #ifdef SERIALCOMMAND_DEBUG
          Serial.println("Line buffer is full - increase SERIALCOMMAND_BUFFER");
        #endif
      }
    }
  }
}

/*
 * Clear the input buffer.
 */
void SerialCommand::clearBuffer() {
  buffer[0] = '\0';
  bufPos = 0;
}

/**
 * Retrieve the next token ("word" or "argument") from the command buffer.
 * Returns NULL if no more tokens exist.
 */
char *SerialCommand::next() {
  return strtok_r(NULL, delim, &last);
}

</file>
<file path="lib/SerialCommand/SerialCommand.h">
/**
 * SerialCommand - A Wiring/Arduino library to tokenize and parse commands
 * received over a serial port.
 * 
 * Copyright (C) 2012 Stefan Rado
 * Copyright (C) 2011 Steven Cogswell <steven.cogswell@gmail.com>
 *                    http://husks.wordpress.com
 * 
 * Version 20120522
 * 
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this library.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifndef SerialCommand_h
#define SerialCommand_h

#if defined(WIRING) && WIRING >= 100
  #include <Wiring.h>
#elif defined(ARDUINO) && ARDUINO >= 100
  #include <Arduino.h>
#else
  #include <WProgram.h>
#endif
#include <string.h>

// Size of the input buffer in bytes (maximum length of one command plus arguments)
#define SERIALCOMMAND_BUFFER 32
// Maximum length of a command excluding the terminating null
#define SERIALCOMMAND_MAXCOMMANDLENGTH 8

// Uncomment the next line to run the library in debug mode (verbose messages)
//#define SERIALCOMMAND_DEBUG


class SerialCommand {
  public:
    SerialCommand();      // Constructor
    void addCommand(const char *command, void(*function)());  // Add a command to the processing dictionary.
    void setDefaultHandler(void (*function)(const char *));   // A handler to call when no valid command received.

    void readSerial();    // Main entry point.
    void clearBuffer();   // Clears the input buffer.
    char *next();         // Returns pointer to next token found in command buffer (for getting arguments to commands).

  private:
    // Command/handler dictionary
    struct SerialCommandCallback {
      char command[SERIALCOMMAND_MAXCOMMANDLENGTH + 1];
      void (*function)();
    };                                    // Data structure to hold Command/Handler function key-value pairs
    SerialCommandCallback *commandList;   // Actual definition for command/handler array
    byte commandCount;

    // Pointer to the default handler function
    void (*defaultHandler)(const char *);

    char delim[2]; // null-terminated list of character to be used as delimeters for tokenizing (default " ")
    char term;     // Character that signals end of command (default '\n')

    char buffer[SERIALCOMMAND_BUFFER + 1]; // Buffer of stored characters while waiting for terminator character
    byte bufPos;                        // Current position in the buffer
    char *last;                         // State variable used by strtok_r during processing
};

#endif //SerialCommand_h

</file>
<file path="src/commands.cpp">
#include "commands.h"
#include <Arduino.h>
#include <NBHX711.h>
#include "config.h"
#include "stepper_control.h"
#include "sensors.h"
#include "valves.h"
#include <SerialCommand.h>

// Объявления внешних переменных для работы с весами
extern NBHX711 scale;
extern bool autoReportWeight;
extern void enableWeightReport();
extern void disableWeightReport();

// Создание экземпляра обработчика команд
SerialCommand sCmd;

// Отправка сообщения о получении команды
void sendReceived() {
  Serial.println(MSG_RECEIVED);
}

// Отправка сообщения о завершении команды
void sendCompleted() {
  Serial.println(MSG_COMPLETED);
}

// Отправка сообщения об ошибке
void sendError(const char* errorMsg) {
  Serial.print(MSG_ERROR);
  Serial.print(": ");
  Serial.println(errorMsg);
}

// Обработка неизвестной команды
void handleUnrecognized(const char* command) {
  Serial.print("Unknown command: ");
  Serial.println(command);
}

// Тестовая функция для проверки связи
void testCommand() {
  Serial.println(F("RECEIVED"));
  Serial.println(F("Test command successful!"));
  Serial.println(F("COMPLETED"));
}

// Настройка обработчиков команд
void setupCommandHandlers() {
  Serial.println(F("Регистрация обработчиков команд..."));
  
  // Movement commands
  sCmd.addCommand("move_multi", handleMoveMulti);
  sCmd.addCommand("move_multizone", handleMoveMultizone);
  sCmd.addCommand("move_rright", handleMoveRRight);

  // Clamp commands для двигателей E0 и E1
  sCmd.addCommand("clamp", handleClamp);
  sCmd.addCommand("clamp_zero", handleClampZero);

  // Homing commands
  sCmd.addCommand("zero_multi", handleZeroMulti);
  sCmd.addCommand("zero_multizone", handleZeroMultizone);
  sCmd.addCommand("zero_rright", handleZeroRRight);
  
  // Pump commands
  Serial.println(F("Регистрация команд насоса..."));
  sCmd.addCommand("pump_on", handlePumpOn);
  sCmd.addCommand("pump_off", handlePumpOff);

  // Valve commands
  Serial.println(F("Регистрация команд клапанов..."));
  sCmd.addCommand("kl1_on", handleKl1On);
  sCmd.addCommand("kl2_on", handleKl2On);
  sCmd.addCommand("kl3_on", handleKl3On);
  sCmd.addCommand("kl1_off", handleKl1Off);
  sCmd.addCommand("kl2_off", handleKl2Off);
  sCmd.addCommand("kl3_off", handleKl3Off);

  // Sensor commands
  Serial.println(F("Регистрация команд датчиков..."));
  sCmd.addCommand("weight", handleWeight);
  sCmd.addCommand("raw_weight", handleRawWeight);
  sCmd.addCommand("calibrate_weight", handleCalibrateWeight);
  sCmd.addCommand("calibrate_weight_factor", handleCalibrateWeightFactor);
  sCmd.addCommand("weight_report_on", handleWeightReportOn);
  sCmd.addCommand("weight_report_off", handleWeightReportOff);
  sCmd.addCommand("staterotor", handleStateRotor);
  sCmd.addCommand("waste", handleWaste);
  
  // Diagnostic commands
  sCmd.addCommand("check_multi_endstop", handleCheckMultiEndstop);
  sCmd.addCommand("check_multizone_endstop", handleCheckMultizoneEndstop);
  sCmd.addCommand("check_rright_endstop", handleCheckRRightEndstop);
  sCmd.addCommand("check_all_endstops", handleCheckAllEndstops);

  // Добавляем тестовую команду
  sCmd.addCommand("test", testCommand);

  Serial.println(F("Установка обработчика для неизвестных команд..."));
  sCmd.setDefaultHandler(handleUnrecognized);
  
  Serial.println(F("Регистрация обработчиков завершена."));
}

// ============== ОБРАБОТЧИКИ КОМАНД ДВИЖЕНИЯ ==============
void handleMoveMulti() {
  sendReceived();
  char* arg = sCmd.next();
  if (arg) {
    if (setStepperPosition(multiStepper, atol(arg))) {
      sendCompleted();
    } else {
      sendError(MSG_NO_POSITION);
    }
  } else {
    sendError(MSG_NO_POSITION);
  }
}

void handleMoveMultizone() {
  sendReceived();
  char* arg = sCmd.next();
  if (arg) {
    if (setStepperPosition(multizoneSteper, atol(arg))) {
      sendCompleted();
    } else {
      sendError(MSG_NO_POSITION);
    }
  } else {
    sendError(MSG_NO_POSITION);
  }
}

void handleMoveRRight() {
  sendReceived();
  char* arg = sCmd.next();
  if (arg) {
    if (setStepperPosition(rRightStepper, atol(arg))) {
      sendCompleted();
    } else {
      sendError(MSG_NO_POSITION);
    }
  } else {
    sendError(MSG_NO_POSITION);
  }
}


// ============== ОБРАБОТЧИКИ КОМАНД ХОМИНГА ==============
void handleZeroMulti() {
  sendReceived();
  if (homeStepperMotor(multiStepper, MULTI_ENDSTOP_PIN)) {
    sendCompleted();
  } else {
    sendError(MSG_HOMING_TIMEOUT);
  }
}

void handleZeroMultizone() {
  sendReceived();
  if (homeStepperMotor(multizoneSteper, MULTIZONE_ENDSTOP_PIN)) {
    sendCompleted();
  } else {
    sendError(MSG_HOMING_TIMEOUT);
  }
}

void handleZeroRRight() {
  sendReceived();
  if (homeStepperMotor(rRightStepper, RRIGHT_ENDSTOP_PIN)) {
    sendCompleted();
  } else {
    sendError(MSG_HOMING_TIMEOUT);
  }
}


// ============== ОБРАБОТЧИКИ КОМАНД НАСОСА ==============
void handlePumpOn() {
  sendReceived();
  Serial.print(F("Включение насоса (пин "));
  Serial.print(PUMP_PIN);
  Serial.println(F(")..."));
  
  setPumpState(true);
  
  Serial.println(F("Насос включен."));
  sendCompleted();
}

void handlePumpOff() {
  sendReceived();
  Serial.print(F("Выключение насоса (пин "));
  Serial.print(PUMP_PIN);
  Serial.println(F(")..."));
  
  setPumpState(false);
  
  Serial.println(F("Насос выключен."));
  sendCompleted();
}

// ============== ОБРАБОТЧИКИ КОМАНД КЛАПАНОВ ==============
void handleKl1On() {
  sendReceived();
  Serial.print(F("Включение клапана KL1 (пин "));
  Serial.print(KL1_PIN);
  Serial.println(F(")..."));
  
  turnValveOn(KL1_PIN);
  
  Serial.println(F("Клапан включен."));
  sendCompleted();
}

void handleKl2On() {
  sendReceived();
  Serial.print(F("Включение клапана KL2 (пин "));
  Serial.print(KL2_PIN);
  Serial.println(F(")..."));
  
  turnValveOn(KL2_PIN);
  
  Serial.println(F("Клапан включен."));
  sendCompleted();
}

void handleKl3On() {
  sendReceived();
  Serial.print(F("Включение клапана KL3 (пин "));
  Serial.print(KL3_PIN);
  Serial.println(F(")..."));
  
  turnValveOn(KL3_PIN);
  
  Serial.println(F("Клапан включен."));
  sendCompleted();
}

void handleKl1Off() {
  sendReceived();
  Serial.print(F("Выключение клапана KL1 (пин "));
  Serial.print(KL1_PIN);
  Serial.println(F(")..."));
  
  turnValveOff(KL1_PIN);
  
  Serial.println(F("Клапан выключен."));
  sendCompleted();
}

void handleKl2Off() {
  sendReceived();
  Serial.print(F("Выключение клапана KL2 (пин "));
  Serial.print(KL2_PIN);
  Serial.println(F(")..."));
  
  turnValveOff(KL2_PIN);
  
  Serial.println(F("Клапан выключен."));
  sendCompleted();
}

void handleKl3Off() {
  sendReceived();
  Serial.print(F("Выключение клапана KL3 (пин "));
  Serial.print(KL3_PIN);
  Serial.println(F(")..."));
  
  turnValveOff(KL3_PIN);
  
  Serial.println(F("Клапан выключен."));
  sendCompleted();
}

// ============== ОБРАБОТЧИКИ КОМАНД ДАТЧИКОВ ==============
void handleWeight() {
  sendReceived();
  float weight = scale.getUnits(5);
  Serial.println(weight, 2);
  sendCompleted();
}

// Обработчик команды для получения сырого (необработанного) значения датчика веса
void handleRawWeight() {
  sendReceived();
  long raw = scale.getRaw();
  Serial.println(raw);
  sendCompleted();
}

// Обработчик команды для получения расширенной отладочной информации о датчике веса
void handleWeightDebug() {
  sendReceived();
  
  long raw_value = scale.getRaw();
  float weight = scale.getUnits(5);
  long offset = scale.getOffset();
  float scale_factor = scale.getScale();
  
  Serial.print(F("Отладка датчика веса:\n"));
  Serial.print(F("Сырое значение: "));
  Serial.print(raw_value);
  Serial.print(F("\nТара (смещение): "));
  Serial.print(offset);
  Serial.print(F("\nКалибровочный коэффициент: "));
  Serial.print(scale_factor);
  Serial.print(F("\nВес в граммах: "));
  Serial.print(weight, 2);
  Serial.print(F("\nСреднее из 10 измерений: "));
  Serial.println(scale.getUnits(10), 2);
  
  sendCompleted();
}

// Обработчик команды обнуления весов
void handleCalibrateWeight() {
  sendReceived();
  Serial.println(F("Запуск процедуры обнуления датчика веса..."));
  
  // Выполняем тарирование
  Serial.println(F("Убедитесь, что на весах ничего нет"));
  delay(2000);
  Serial.println(F("Начинаю обнуление..."));
  scale.tare();
  Serial.println(F("Датчик веса успешно обнулен!"));
  
  sendCompleted();
}

// Чтение состояния ротора
void handleStateRotor() {
  sendReceived();
  char state[5];
  readRotorState(state);
  Serial.println(state);
  sendCompleted();
}

// Чтение состояния датчика отходов
void handleWaste() {
  sendReceived();
  Serial.println(readWasteSensor() ? "1" : "0");
  sendCompleted();
}

// ============== ОБРАБОТЧИКИ ДИАГНОСТИЧЕСКИХ КОМАНД ==============
void handleCheckMultiEndstop() {
  sendReceived();
  bool state = readEndstopState(MULTI_ENDSTOP_PIN);
  Serial.print("Multi endstop: ");
  Serial.println(state ? "TRIGGERED" : "NOT TRIGGERED");
  sendCompleted();
}

void handleCheckMultizoneEndstop() {
  sendReceived();
  bool state = readEndstopState(MULTIZONE_ENDSTOP_PIN);
  Serial.print("Multizone endstop: ");
  Serial.println(state ? "TRIGGERED" : "NOT TRIGGERED");
}

void handleCheckRRightEndstop() {
  sendReceived();
  bool state = readEndstopState(RRIGHT_ENDSTOP_PIN);
  Serial.print("RRight endstop: ");
  Serial.println(state ? "TRIGGERED" : "NOT TRIGGERED");
}


void handleCheckAllEndstops() {
  sendReceived();
  handleCheckMultiEndstop();
  handleCheckMultizoneEndstop();
  handleCheckRRightEndstop();
}

// Обработчик команды для включения автоматического отчета о весе
void handleWeightReportOn() {
  sendReceived();
  enableWeightReport();
  sendCompleted();
}

// Обработчик команды для выключения автоматического отчета о весе
void handleWeightReportOff() {
  sendReceived();
  disableWeightReport();
  sendCompleted();
}

void handleDisableWeightReport() {
  disableWeightReport();
  Serial.println(F("WEIGHT_REPORT:DISABLED"));
}

// Обработчик команды для установки калибровочного коэффициента
void handleCalibrateWeightFactor() {
  sendReceived();
  
  char* arg = sCmd.next();
  if (arg) {
    float factor = atof(arg);
    Serial.print(F("Установка калибровочного коэффициента: "));
    Serial.println(factor);
    
    // Установка калибровочного коэффициента
    scale.setScale(factor);
    
    sendCompleted();
  } else {
    sendError(MSG_MISSING_PARAMETER);
  }
}

// ============== ОБРАБОТЧИКИ КОМАНД ДЛЯ ДВИГАТЕЛЕЙ E0 И E1 ==============
void handleClamp() {
  sendReceived();
  char* arg = sCmd.next();
  if (arg) {
    long steps = atol(arg);
    if (steps != 0) {
      if (clampMotors(steps)) {
        sendCompleted();
      } else {
        sendError(MSG_INVALID_VALUE);
      }
    } else {
      sendError(MSG_INVALID_VALUE);
    }
  } else {
    sendError(MSG_MISSING_PARAMETER);
  }
}

void handleClampZero() {
  sendReceived();
  if (clampZeroMotors()) {
    // Команда запущена успешно
    sendCompleted();
  } else {
    // Уже выполняется другая команда
    sendError("ALREADY_RUNNING");
  }
}
</file>
<file path="src/main.ino">
#include <Arduino.h>
#include <Bounce2.h>
#include <NBHX711.h>
#include "config.h"
#include "stepper_control.h"
#include "valves.h"
#include "commands.h"

// Объект для работы с датчиком веса
NBHX711 scale(WEIGHT_SENSOR_DT, WEIGHT_SENSOR_SCK, 16);
Bounce tara;

// Флаг для включения/выключения периодической отправки веса
bool autoReportWeight = false;

// Включить автоматический отчет о весе
void enableWeightReport() {
  autoReportWeight = true;
  Serial.println(F("Автоматический отчет о весе ВКЛЮЧЕН"));
}

// Выключить автоматический отчет о весе
void disableWeightReport() {
  autoReportWeight = false;
  Serial.println(F("Автоматический отчет о весе ВЫКЛЮЧЕН"));
}

// ============== SETUP ==============
void setup() {
  // Инициализация последовательного порта
  Serial.begin(115200);
  
  // Задержка для стабилизации порта
  delay(1000);
  
  Serial.println(F("======== CИСТЕМА ЗАПУСКАЕТСЯ ========"));
  Serial.println(F("Версия: 1.0"));
  
  // Инициализация шаговых двигателей
  initializeSteppers();
  
  // Инициализация датчика веса
  scale.begin();
  scale.setScale(2230.0); // Установить калибровочный коэффициент
  scale.tare(); // Тарируем весы при запуске
  Serial.println(F("Датчик веса инициализирован и тарирован."));
  
  // Кнопка тарирования весов (переназначим пин, если KL1_PIN используется)
  // Убедитесь, что TARA_BUTTON_PIN не конфликтует с другими пинами!
  #define TARA_BUTTON_PIN 9 // Пример: используем пин 9 для кнопки тары
  tara.attach(TARA_BUTTON_PIN, INPUT_PULLUP); 
  Serial.print(F("Кнопка тарирования подключена к пину: ")); Serial.println(TARA_BUTTON_PIN);
  
  // Инициализация клапанов
  initializeValves();
  
  // Настройка обработчиков команд
  setupCommandHandlers();
  
  // Отправляем тестовое сообщение, чтобы убедиться, что все работает
  Serial.println();
  Serial.println(F("======== СИСТЕМА ГОТОВА ========"));
  // Обновим список команд, если команды серво были добавлены
  Serial.println(F("Доступные команды:"));
  Serial.println(F("- test: проверка связи"));
  Serial.println(F("- move_multi <шаги>, move_multizone <шаги>, move_rright <шаги>"));
  Serial.println(F("- zero_multi, zero_multizone, zero_rright"));
  Serial.println(F("- clamp <шаги>, clamp_zero"));
  Serial.println(F("- kl1_on/off, kl2_on/off, kl3_on/off"));
  Serial.println(F("- pump_on/off"));
  Serial.println(F("- weight: получить вес"));
  Serial.println(F("- raw_weight: получить сырое значение"));
  Serial.println(F("- calibrate_weight: тарировать весы"));
  Serial.println(F("- calibrate_weight_factor <число>: установить калибровочный коэффициент"));
  // Добавим команды серво, если они есть в commands.cpp
  // Serial.println(F("- servo1 <проценты>, servo2 <проценты>"));
  // Serial.println(F("- reset_servos")); 
  // Serial.println(F("- servo_test_on/off"));
  Serial.println();
  Serial.println(F("Ожидание команд..."));
}

// ============== MAIN LOOP ==============
void loop() {
  // УДАЛЕНО: static unsigned long lastWeightReportTime = 0;
  // УДАЛЕНО: static bool firstTime = true;
  // УДАЛЕНО: static byte initialCount = 0;
  
  // Обработка входящих команд
  if (Serial.available() > 0) {
    sCmd.readSerial();
  }
  
  // УДАЛЕНО: Обработка кнопки тарирования
  // if (tara.update() && tara.fell()) { ... }
  
  // УДАЛЕНО: Обновление состояния датчика веса
  // scale.update(); 

  // УДАЛЕНО: Логика автоматической отправки веса
  // if (autoReportWeight && (millis() - lastWeightReportTime >= 1000)) { ... }
  
  // УДАЛЕНО: Обновление состояния шаговых двигателей
  // updateSteppers(); 
} 
</file>
<file path="src/sensors.cpp">
#include "sensors.h"
#include <Arduino.h>

// Массив пинов ротора
const byte rotorPins[4] = ROTOR_PINS;

// Инициализация пинов датчиков
void initializeSensors() {
  // Датчик отходов
  pinMode(WASTE_PIN, INPUT_PULLUP);
  
  // Пины ротора
  for (int i = 0; i < 4; i++) {
    pinMode(rotorPins[i], INPUT_PULLUP);
  }
}

// Чтение состояния ротора
void readRotorState(char* stateBuffer) {
  for (int i = 0; i < 4; i++) {
    stateBuffer[i] = digitalRead(rotorPins[i]) ? '1' : '0';
  }
  stateBuffer[4] = '\0';
}

// Чтение состояния датчика отходов
bool readWasteSensor() {
  return digitalRead(WASTE_PIN);
}

// Чтение состояния концевых выключателей
bool readEndstopState(int endstopPin) {
  return !digitalRead(endstopPin); // Инвертировано, так как INPUT_PULLUP
} 
</file>
<file path="src/stepper_control.cpp">
#include "stepper_control.h"

// Создание экземпляров шаговых двигателей (используем GStepper2)
GStepper2<STEPPER2WIRE> multiStepper(200, MULTI_STEP_PIN, MULTI_DIR_PIN, MULTI_ENABLE_PIN);
GStepper2<STEPPER2WIRE> multizoneSteper(200, MULTIZONE_STEP_PIN, MULTIZONE_DIR_PIN, MULTIZONE_ENABLE_PIN);
GStepper2<STEPPER2WIRE> rRightStepper(200, RRIGHT_STEP_PIN, RRIGHT_DIR_PIN, RRIGHT_ENABLE_PIN);
GStepper2<STEPPER2WIRE> e0Stepper(200, E0_STEP_PIN, E0_DIR_PIN, E0_ENABLE_PIN);
GStepper2<STEPPER2WIRE> e1Stepper(200, E1_STEP_PIN, E1_DIR_PIN, E1_ENABLE_PIN);

// Флаг для предотвращения одновременного запуска команд, влияющих на E0/E1
bool clampInProgress = false;

// Инициализация шаговых двигателей
void initializeSteppers() {
  // Проверяем пины для E0 и E1, чтобы убедиться, что они правильно определены
  pinMode(E0_STEP_PIN, OUTPUT);
  pinMode(E0_DIR_PIN, OUTPUT);
  pinMode(E0_ENABLE_PIN, OUTPUT);
  pinMode(E1_STEP_PIN, OUTPUT);
  pinMode(E1_DIR_PIN, OUTPUT);
  pinMode(E1_ENABLE_PIN, OUTPUT);
  
  // Включаем двигатели (активный LOW)
  // digitalRead(E0_ENABLE_PIN); // Не нужно читать, просто устанавливаем
  digitalWrite(E0_ENABLE_PIN, LOW);
  digitalWrite(E1_ENABLE_PIN, LOW);
  
  // Настройка общих параметров для всех двигателей
  auto config = [](GStepper2<STEPPER2WIRE>& stepper) {
    stepper.enable(); // Включаем enable пин (если есть)
    // stepper.autoPower(true); // В GStepper2 этого метода нет, enable управляется явно
    // stepper.setRunMode(FOLLOW_POS); // В GStepper2 это режим по умолчанию при setTarget
    stepper.setMaxSpeed(500); // Устанавливаем максимальную скорость для движения к цели
    stepper.setAcceleration(800);
  };

  config(multiStepper);
  config(multizoneSteper);
  config(rRightStepper);
  config(e0Stepper);
  config(e1Stepper);
  
  // Настроим пин датчика для функции clamp_zero
  pinMode(CLAMP_SENSOR_PIN, INPUT_PULLUP);
}

// Установка позиции для двигателя (блокирующая, с GyverStepper2)
bool setStepperPosition(GStepper2<STEPPER2WIRE>& stepper, long position) {
  if (position == 0) {
    Serial.println(F("Ошибка: Нулевая позиция не допускается.")); 
    return false; 
  }
  
  // Проверка для E0 и E1, если они заняты командой clamp
  if ((&stepper == &e0Stepper || &stepper == &e1Stepper) && clampInProgress) {
      Serial.println(F("Ошибка: Двигатели E0/E1 заняты командой clamp."));
      return false;
  }
  
  stepper.setTarget(position); // Устанавливаем цель (абсолютную по умолчанию)
  
  // Блокирующий цикл ожидания завершения движения (используем ready() и tick())
  while (!stepper.ready()) { // Ждем, пока ready() не вернет true
    stepper.tick();
    yield(); 
  } 
  
  return true;
}

// Выполнение хоминга для двигателя (блокирующее, с GyverStepper2)
bool homeStepperMotor(GStepper2<STEPPER2WIRE>& stepper, int endstopPin) {
  
  // Проверка для E0 и E1, если они заняты командой clamp
  if ((&stepper == &e0Stepper || &stepper == &e1Stepper) && clampInProgress) {
      Serial.println(F("Ошибка: Двигатели E0/E1 заняты командой clamp."));
      return false;
  }
    
  // stepper.setRunMode(KEEP_SPEED); // В GStepper2 нет setRunMode, используем setSpeed для вращения
  stepper.setSpeed(-HOMING_SPEED); // Запускаем вращение с постоянной скоростью
  
  unsigned long startTime = millis();
  // Блокирующий цикл ожидания срабатывания концевика
  while (digitalRead(endstopPin)) {
    if (millis() - startTime >= HOMING_TIMEOUT) {
       stepper.brake(); // Останавливаем двигатель при таймауте
       Serial.println(F("Ошибка: Таймаут хоминга!"));
       return false; // Ошибка таймаута
    }
    stepper.tickManual(); // Используем tickManual, так как tick() остановит мотор после setSpeed()
    yield(); 
  }
  
  // Концевик сработал
  stepper.brake(); // Останавливаем вращение
  stepper.reset(); // Сбрасываем текущую позицию в 0
  delay(50); // Небольшая пауза
  
  // Отъезжаем от концевика на 100 шагов
  // stepper.setRunMode(FOLLOW_POS); // Режим по умолчанию
  stepper.setTarget(100); // Устанавливаем цель для отъезда
  
  // Блокирующий цикл ожидания завершения отъезда
  while (!stepper.ready()) {
      stepper.tick(); // Используем tick() для движения к цели
      yield();
  } 
  
  stepper.reset(); // Снова сбрасываем позицию в 0 после отъезда - теперь это наша нулевая точка
  
  return true;
}

// Синхронное вращение двигателей E0 и E1 на заданное количество шагов (блокирующее, с GyverStepper2)
bool clampMotors(long steps) {
  if (steps == 0) {
    Serial.println(F("Ошибка: Нулевое количество шагов для clamp."));
    return false; 
  }
  
  if (clampInProgress) {
    Serial.println(F("Ошибка: Команда clamp уже выполняется."));
    return false; 
  }
  
  clampInProgress = true; // Устанавливаем флаг занятости
  
  // Настраиваем параметры движения
  e0Stepper.setMaxSpeed(CLAMP_SPEED); 
  e1Stepper.setMaxSpeed(CLAMP_SPEED);
  e0Stepper.setAcceleration(CLAMP_ACCELERATION); // <--- Устанавливаем ускорение
  e1Stepper.setAcceleration(CLAMP_ACCELERATION); // <--- Устанавливаем ускорение
  
  // Устанавливаем целевые позиции относительно текущих
  // Используем относительное позиционирование GS_posType::RELATIVE
  e0Stepper.setTarget(steps, RELATIVE);
  e1Stepper.setTarget(steps, RELATIVE);
  
  // Блокирующий цикл ожидания завершения движения ОБОИХ двигателей
  while (!e0Stepper.ready() || !e1Stepper.ready()) { // Ждем, пока ОБА не будут ready()
    if (!e0Stepper.ready()) e0Stepper.tick(); // Tick только для тех, кто еще не готов
    if (!e1Stepper.ready()) e1Stepper.tick();
    yield();
  }
  
  clampInProgress = false; // Снимаем флаг занятости
  return true;
}

// Обнуление двигателей E0 и E1 по датчику CLAMP_SENSOR_PIN (блокирующее, с GyverStepper2)
bool clampZeroMotors() {
  if (clampInProgress) {
    Serial.println(F("Ошибка: Команда clamp уже выполняется."));
    return false; 
  }
  
  clampInProgress = true; // Устанавливаем флаг занятости
  
  // Устанавливаем ускорение перед движением
  e0Stepper.setAcceleration(CLAMP_ACCELERATION); // <--- Устанавливаем ускорение
  e1Stepper.setAcceleration(CLAMP_ACCELERATION); // <--- Устанавливаем ускорение
  
  // Настраиваем режим и скорость для хоминга
  e0Stepper.setSpeed(-CLAMP_ZERO_SPEED); 
  // e0Stepper.setRunMode(KEEP_SPEED);
  // e1Stepper.setRunMode(KEEP_SPEED);
  e0Stepper.setSpeed(-CLAMP_ZERO_SPEED); // Запускаем вращение
  e1Stepper.setSpeed(-CLAMP_ZERO_SPEED);
  
  unsigned long startTime = millis();
  
  // Движение к датчику
  Serial.println(F("ClampZero: Движение к датчику..."));
  while (digitalRead(CLAMP_SENSOR_PIN)) { // Движемся, пока датчик НЕ нажат (HIGH)
      if (millis() - startTime >= HOMING_TIMEOUT) {
          e0Stepper.brake();
          e1Stepper.brake();
          Serial.println(F("Ошибка: Таймаут ClampZero при движении к датчику!"));
          clampInProgress = false; // Снимаем флаг
          return false; // Таймаут
      }
      // Используем tickManual для обоих, так как tick() остановит вращение
      e0Stepper.tickManual(); 
      e1Stepper.tickManual();
      yield();
  }
  
  // Датчик сработал
  Serial.println(F("ClampZero: Датчик сработал."));
  e0Stepper.brake();
  e1Stepper.brake();
  e0Stepper.reset(); // Сбрасываем позиции в 0
  e1Stepper.reset();
  delay(50); // Пауза
  
  // Отъезжаем от датчика на 100 шагов
  Serial.println(F("ClampZero: Отъезд от датчика..."));
  // e0Stepper.setRunMode(FOLLOW_POS);
  // e1Stepper.setRunMode(FOLLOW_POS);
  e0Stepper.setTarget(100); // Устанавливаем цель
  e1Stepper.setTarget(100);
  
  // Блокирующий цикл ожидания завершения отъезда
  while (!e0Stepper.ready() || !e1Stepper.ready()) { // Ждем готовности обоих
      if (!e0Stepper.ready()) e0Stepper.tick();
      if (!e1Stepper.ready()) e1Stepper.tick();
      yield();
  }
  
  e0Stepper.reset(); // Снова сбрасываем позицию в 0 - это наша новая нулевая точка
  e1Stepper.reset();
  Serial.println(F("ClampZero: Обнуление завершено."));
  
  clampInProgress = false; // Снимаем флаг занятости
  return true;
} 
</file>
<file path="src/valves.cpp">
#include "valves.h"
#include <Arduino.h>

// Инициализация пинов клапанов и насоса
void initializeValves() {
  // Насос
  pinMode(PUMP_PIN, OUTPUT);
  digitalWrite(PUMP_PIN, LOW);
  
  // Клапаны
  pinMode(KL1_PIN, OUTPUT);
  pinMode(KL2_PIN, OUTPUT);
  pinMode(KL3_PIN, OUTPUT);
  
  digitalWrite(KL1_PIN, LOW);
  digitalWrite(KL2_PIN, LOW);
  digitalWrite(KL3_PIN, LOW);
}

// Управление насосом
void setPumpState(bool state) {
  digitalWrite(PUMP_PIN, state ? HIGH : LOW);
}

// Переключение состояния клапана
void toggleValveState(int valvePin) {
  digitalWrite(valvePin, !digitalRead(valvePin));
}

// Установка состояния клапана
void setValveState(int valvePin, bool state) {
  digitalWrite(valvePin, state ? HIGH : LOW);
}

// Включение клапана
void turnValveOn(int valvePin) {
  setValveState(valvePin, HIGH);
}

// Выключение клапана
void turnValveOff(int valvePin) {
  setValveState(valvePin, LOW);
} 
</file>
<file path=".gitignore">
.pio
.vscode/.browse.c_cpp.db*
.vscode/c_cpp_properties.json
.vscode/launch.json
.vscode/ipch

</file>
<file path="platformio.ini">
[env:mega]
platform = atmelavr
board = megaatmega2560
framework = arduino

# Корректное подключение библиотек
lib_deps = 
    gyverlibs/GyverStepper@^2.7
    SerialCommand

# Дополнительные флаги сборки
build_flags = 
    -I"${PROJECT_DIR}/include"
    -I"${PROJECT_DIR}/lib"

# Совместимость библиотек
lib_compat_mode = off

</file>
<file path="README.md">
# Система управления автоматикой

Данный проект представляет собой систему управления на базе Arduino для контроля шаговых двигателей, клапанов и датчиков, реализованную на плате MKS Gen L v1.

## Аппаратная часть

Система включает в себя:
- 4 шаговых двигателя (Multi, Multizone, RRight, RLeft)
- Насос (Pump) с цифровым управлением
- 3 клапана (KL1, KL2, KL3)
- 4 сервопривода MG996 (две группы по два сервопривода)
- Датчик веса на основе HX711
- Датчик отходов
- Ротор с 4 датчиками

## Подключение

Назначение пинов для платы MKS Gen L v1:

### Шаговые двигатели
- **Multi** (X): STEP (A0), DIR (A1), ENABLE (38), ENDSTOP (3)
- **Multizone** (Y): STEP (A6), DIR (A7), ENABLE (A2), ENDSTOP (2)
- **RRight** (Z): STEP (46), DIR (48), ENABLE (A8), ENDSTOP (14)
- **RLeft** (E0): STEP (26), DIR (28), ENABLE (24), ENDSTOP (15)

### Насос и клапаны
- **Pump**: пин 18
- **KL1**: пин 8
- **KL2**: пин 10
- **KL3**: пин 7

### Сервоприводы
- **Servo1 группа**: пины 4 и 5
- **Servo2 группа**: пины 6 и 11

### Датчики
- **Датчик веса HX711**:
  - SCK: 20
  - DT: 21
- **Датчик отходов**: 19
- **Ротор**: пины 27, 29, 23, 25

## Коммуникация

Управление осуществляется через последовательный порт со скоростью 115200 бод. Команды отправляются в текстовом формате.

## Структура кода

Код разделен на несколько модулей для облегчения восприятия и поддержки:

- **src/main.ino** - основной файл с функциями setup() и loop()
- **src/include/config.h** - определения пинов, констант и сообщений
- **src/include/stepper_control.h** и **src/stepper_control.cpp** - управление шаговыми двигателями
- **src/include/sensors.h** и **src/sensors.cpp** - работа с датчиками
- **src/include/valves.h** и **src/valves.cpp** - управление клапанами и насосом
- **src/include/servo_control.h** и **src/servo_control.cpp** - управление сервоприводами
- **src/include/commands.h** и **src/commands.cpp** - обработка команд и связь через последовательный порт

### Организация файлов

```
└── src/
    ├── main.ino                 # Основной файл программы
    ├── stepper_control.cpp      # Реализация управления двигателями
    ├── sensors.cpp              # Реализация работы с датчиками
    ├── valves.cpp               # Реализация управления клапанами
    ├── servo_control.cpp        # Реализация управления сервоприводами
    ├── commands.cpp             # Реализация обработки команд
    └── include/                 # Папка с заголовочными файлами
        ├── config.h             # Определения пинов и констант
        ├── stepper_control.h    # Объявления функций для двигателей
        ├── sensors.h            # Объявления функций для датчиков
        ├── valves.h             # Объявления функций для клапанов
        ├── servo_control.h      # Объявления функций для сервоприводов
        └── commands.h           # Объявления функций для команд
```

## Список команд управления

### Движение шаговых двигателей
- `move_multi <шаги>` - перемещение Multi-двигателя на указанное количество шагов
- `move_multizone <шаги>` - перемещение Multizone-двигателя на указанное количество шагов
- `move_rright <шаги>` - перемещение RRight-двигателя на указанное количество шагов
- `move_rleft <шаги>` - перемещение RLeft-двигателя на указанное количество шагов

### Настройка нулевого положения (хоминг)
- `zero_multi` - поиск нулевого положения для Multi-двигателя
- `zero_multizone` - поиск нулевого положения для Multizone-двигателя
- `zero_rright` - поиск нулевого положения для RRight-двигателя
- `zero_rleft` - поиск нулевого положения для RLeft-двигателя

### Управление насосом
- `pump_on` - включение насоса
- `pump_off` - выключение насоса

### Управление клапанами
- `kl1_on` - включение клапана KL1
- `kl2_on` - включение клапана KL2
- `kl3_on` - включение клапана KL3
- `kl1_off` - выключение клапана KL1
- `kl2_off` - выключение клапана KL2
- `kl3_off` - выключение клапана KL3

### Управление сервоприводами
- `servo1 <процент>` - установка положения сервоприводов первой группы (пины 4, 5), значение от 0 до 100
- `servo2 <процент>` - установка положения сервоприводов второй группы (пины 6, 11), значение от 0 до 100

### Чтение датчиков
- `weight` - чтение значения датчика веса (возвращает вес в граммах)
- `calibrate_weight` - запуск процедуры обнуления датчика веса
- `staterotor` - чтение состояния 4 датчиков ротора (возвращает строку из 4 символов, где '0' - активен, '1' - неактивен)
- `waste` - чтение состояния датчика отходов (возвращает '0' - активен, '1' - неактивен)

### Диагностические команды
- `check_multi_endstop` - проверка состояния концевого выключателя Multi-двигателя
- `check_multizone_endstop` - проверка состояния концевого выключателя Multizone-двигателя
- `check_rright_endstop` - проверка состояния концевого выключателя RRight-двигателя
- `check_rleft_endstop` - проверка состояния концевого выключателя RLeft-двигателя
- `check_all_endstops` - проверка состояния всех концевых выключателей

## Формат ответов

После получения команды система немедленно отвечает подтверждением:
- `RECEIVED` - команда получена и обрабатывается

По завершении выполнения команды система отвечает одним из следующих сообщений:
- `COMPLETED` - команда успешно выполнена
- `ERR: [текст ошибки]` - ошибка выполнения с указанием причины
- Числовое значение - при запросе состояния датчиков
- Диагностическая информация - при использовании диагностических команд

## Примеры использования

```
# Отправка команды и ожидаемые ответы
> move_multi 1000
< RECEIVED
< COMPLETED

# Пример ошибки
> move_multi
< RECEIVED
< ERR: NO POSITION

# Чтение датчиков
> weight
< RECEIVED
< 512

# Обнуление датчика веса
> calibrate_weight
< RECEIVED
< Запуск процедуры обнуления датчика веса...
< Убедитесь, что на весах ничего нет
< Начинаю обнуление...
< Датчик веса успешно обнулен!
< COMPLETED

# Включение насоса
> pump_on
< RECEIVED
< COMPLETED

# Включение и выключение клапана
> kl1_on
< RECEIVED
< COMPLETED

> kl1_off
< RECEIVED
< COMPLETED

# Управление сервоприводами
> servo1 50
< RECEIVED
< COMPLETED

> servo2 75
< RECEIVED
< COMPLETED
```

## Датчик веса HX711

Для работы с датчиком веса HX711 используется неблокирующая библиотека [NBHX711](https://github.com/whandall/NBHX711), которая позволяет считывать данные с датчика без блокировки основного цикла выполнения программы. Это обеспечивает плавную работу всей системы и мгновенный отклик на команды даже во время измерения веса.

### Особенности работы с весами

- Датчик работает в неблокирующем режиме, обновляя данные в фоновом режиме
- Используется буфер из 16 последних измерений для сглаживания показаний
- Для обнуления (тарирования) датчика используйте команду `calibrate_weight`
- Для правильной работы функция `updateWeightSensor()` вызывается в каждой итерации основного цикла `loop()`

### Процесс обнуления весов

1. Убедитесь, что на весах ничего нет
2. Отправьте команду `calibrate_weight`
3. Дождитесь сообщения о начале обнуления
4. Через несколько секунд появится сообщение об успешном обнулении датчика
5. Теперь можно использовать весы для измерений (команда `weight`)

## Примечания

- Датчик веса HX711 работает в неблокирующем режиме для обеспечения отзывчивости системы
- Хоминг выполняется в течение максимум 10 секунд, после чего выдается ошибка таймаута
- После успешного хоминга двигатель отъезжает на 100 шагов от концевого выключателя
- Скорость двигателей установлена на 500 шагов/сек с ускорением 800 шагов/сек²
- Скорость хоминга составляет 300 шагов/сек
- При диагностике концевых выключателей состояние отображается как "TRIGGERED" (сработал) или "NOT TRIGGERED" (не сработал)

## Отладка и устранение неполадок

### Проблемы связи

Если плата не отвечает на команды или связь работает некорректно, проверьте следующее:

1. **Правильный формат команд**: Убедитесь, что каждая команда заканчивается символом новой строки (`\n`). Некоторые терминалы требуют ручного добавления символа новой строки.

2. **Скорость последовательного порта**: Убедитесь, что скорость последовательного порта установлена на 115200 бод.

3. **Правильный порт**: Проверьте, подключены ли вы к правильному COM-порту.

4. **Тайминг**: После подключения к Arduino подождите несколько секунд, чтобы Arduino завершила инициализацию и была готова принимать команды.

5. **Загрузите тестовый скетч**: В каталоге `src/test_serial` находится упрощенный скетч для проверки связи. Загрузите его для диагностики проблем с последовательным портом.

### Улучшенный тестовый скетч

Для диагностики проблем с последовательной связью в проекте есть специальный тестовый скетч (`src/test_serial/test_serial.ino`), который предоставляет следующие функции:

1. **Визуальная индикация запуска** - мигание светодиода при запуске
2. **Проверка связи** - команда `ping` возвращает `pong`
3. **Управление LED** - команды `on`, `off`, `blink` для проверки выходов
4. **Эхо-режим** - команда `echo <текст>` возвращает введенный текст
5. **Информация о системе** - команда `info` выводит данные о плате
6. **Периодические сообщения** - каждые 2 секунды система отправляет напоминание о готовности

Порядок использования тестового скетча:

1. Загрузите скетч `src/test_serial/test_serial.ino` на плату MKS Gen L v1
2. Откройте монитор последовательного порта со скоростью 115200 бод
3. Убедитесь, что видите начальное сообщение о запуске
4. Отправьте тестовую команду, например `ping`, для проверки связи
5. Обратите внимание на мигание встроенного светодиода на плате

### Отладочные инструменты

1. **Команда test**: Отправьте команду `test` для проверки связи. Плата должна ответить:
   ```
   RECEIVED
   Test command successful!
   COMPLETED
   ```

2. **Мониторинг инициализации**: При старте плата должна выдавать подробную информацию о процессе инициализации, включая назначение пинов. Если эти сообщения не отображаются, возможно, проблема с питанием или соединением.

3. **Светодиод на плате**: При получении и обработке команд на плате должен мигать встроенный светодиод. Если светодиод не мигает при отправке команд, это может указывать на проблемы с получением команд.

### Пошаговая диагностика проблем связи

Если плата не отвечает на отправляемые команды, выполните следующие шаги для диагностики:

1. **Проверка базовой работы платы**:
   - Загрузите простейший скетч Blink из примеров Arduino IDE
   - Убедитесь, что встроенный светодиод мигает
   - Это подтвердит, что плата работает и процесс загрузки скетчей функционирует

2. **Проверка последовательного порта**:
   - Загрузите тестовый скетч из `src/test_serial`
   - Откройте монитор порта и проверьте, отображаются ли сообщения о запуске
   - Проверьте, что при отправке команды `ping` приходит ответ `pong`

3. **Проверка основного скетча**:
   - Загрузите основной скетч из `src/main.ino`
   - Проверьте, выводятся ли сообщения о процессе инициализации
   - Отправьте простейшую команду `test` и проверьте ответ

4. **Диагностика времени отклика**:
   - Измерьте время между отправкой команды и получением ответа
   - Если ответ приходит с большой задержкой, возможно, есть проблемы с производительностью

5. **Проверка формата команд**:
   - Убедитесь, что каждая команда заканчивается переводом строки (`\n`)
   - Проверьте, не добавляет ли терминал дополнительные символы (например, `\r`)

### Возможные решения

1. **Перезагрузка платы**: Перезагрузите плату, нажав кнопку Reset.

2. **Проверка питания**: Убедитесь, что плата получает достаточно питания. Проблемы с питанием могут вызывать нестабильную работу.

3. **Перезагрузка ПК и порта**: Отключите и снова подключите USB-кабель, перезагрузите последовательный терминал.

4. **Изоляция проблемы**: Если возможно, отключите некоторые устройства (двигатели, датчики) для исключения помех или конфликтов.

5. **Проверка библиотек**: Убедитесь, что все необходимые библиотеки установлены и их версии совместимы с вашей платой.

6. **Проверка скорости порта**: Попробуйте уменьшить скорость порта до 9600 бод в тестовом скетче для проверки стабильности связи.

7. **Замена USB-кабеля**: Некоторые USB-кабели могут иметь проблемы с передачей данных, особенно длинные или недостаточно экранированные.

8. **Использование другого USB-порта**: Некоторые USB-порты на компьютере могут работать нестабильно.

Если проблема сохраняется даже при использовании тестового скетча, возможно, есть аппаратные проблемы с платой или компьютером, и может потребоваться замена оборудования или обращение к специалистам.
</file>
*(This section may contain "N/A" or be empty if the task does not require analysis of an existing codebase or if the file structure is not provided.)*