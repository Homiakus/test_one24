# Система управления автоматикой

Данный проект представляет собой систему управления на базе Arduino для контроля шаговых двигателей, клапанов и датчиков, реализованную на плате MKS Gen L v1.

## Аппаратная часть

Система включает в себя:
- 4 шаговых двигателя (Multi, Multizone, RRight, RLeft)
- Насос (Pump) с цифровым управлением
- 3 клапана (KL1, KL2, KL3)
- 4 сервопривода MG996 (две группы по два сервопривода)
- Датчик веса на основе HX711
- Датчик отходов
- Ротор с 4 датчиками

## Подключение

Назначение пинов для платы MKS Gen L v1:

### Шаговые двигатели
- **Multi** (X): STEP (A0), DIR (A1), ENABLE (38), ENDSTOP (3)
- **Multizone** (Y): STEP (A6), DIR (A7), ENABLE (A2), ENDSTOP (2)
- **RRight** (Z): STEP (46), DIR (48), ENABLE (A8), ENDSTOP (14)
- **RLeft** (E0): STEP (26), DIR (28), ENABLE (24), ENDSTOP (15)

### Насос и клапаны
- **Pump**: пин 18
- **KL1**: пин 8
- **KL2**: пин 10
- **KL3**: пин 7

### Сервоприводы
- **Servo1 группа**: пины 4 и 5
- **Servo2 группа**: пины 6 и 11

### Датчики
- **Датчик веса HX711**:
  - SCK: 20
  - DT: 21
- **Датчик отходов**: 19
- **Ротор**: пины 27, 29, 23, 25

## Коммуникация

Управление осуществляется через последовательный порт со скоростью 115200 бод. Команды отправляются в текстовом формате.

## Структура кода

Код разделен на несколько модулей для облегчения восприятия и поддержки:

- **src/main.ino** - основной файл с функциями setup() и loop()
- **src/include/config.h** - определения пинов, констант и сообщений
- **src/include/stepper_control.h** и **src/stepper_control.cpp** - управление шаговыми двигателями
- **src/include/sensors.h** и **src/sensors.cpp** - работа с датчиками
- **src/include/valves.h** и **src/valves.cpp** - управление клапанами и насосом
- **src/include/servo_control.h** и **src/servo_control.cpp** - управление сервоприводами
- **src/include/commands.h** и **src/commands.cpp** - обработка команд и связь через последовательный порт

### Организация файлов

```
└── src/
    ├── main.ino                 # Основной файл программы
    ├── stepper_control.cpp      # Реализация управления двигателями
    ├── sensors.cpp              # Реализация работы с датчиками
    ├── valves.cpp               # Реализация управления клапанами
    ├── servo_control.cpp        # Реализация управления сервоприводами
    ├── commands.cpp             # Реализация обработки команд
    └── include/                 # Папка с заголовочными файлами
        ├── config.h             # Определения пинов и констант
        ├── stepper_control.h    # Объявления функций для двигателей
        ├── sensors.h            # Объявления функций для датчиков
        ├── valves.h             # Объявления функций для клапанов
        ├── servo_control.h      # Объявления функций для сервоприводов
        └── commands.h           # Объявления функций для команд
```

## Список команд управления

### Движение шаговых двигателей
- `move_multi <шаги>` - перемещение Multi-двигателя на указанное количество шагов
- `move_multizone <шаги>` - перемещение Multizone-двигателя на указанное количество шагов
- `move_rright <шаги>` - перемещение RRight-двигателя на указанное количество шагов
- `move_rleft <шаги>` - перемещение RLeft-двигателя на указанное количество шагов

### Настройка нулевого положения (хоминг)
- `zero_multi` - поиск нулевого положения для Multi-двигателя
- `zero_multizone` - поиск нулевого положения для Multizone-двигателя
- `zero_rright` - поиск нулевого положения для RRight-двигателя
- `zero_rleft` - поиск нулевого положения для RLeft-двигателя

### Управление насосом
- `pump_on` - включение насоса
- `pump_off` - выключение насоса

### Управление клапанами
- `kl1_on` - включение клапана KL1
- `kl2_on` - включение клапана KL2
- `kl3_on` - включение клапана KL3
- `kl1_off` - выключение клапана KL1
- `kl2_off` - выключение клапана KL2
- `kl3_off` - выключение клапана KL3

### Управление сервоприводами
- `servo1 <процент>` - установка положения сервоприводов первой группы (пины 4, 5), значение от 0 до 100
- `servo2 <процент>` - установка положения сервоприводов второй группы (пины 6, 11), значение от 0 до 100

### Чтение датчиков
- `weight` - чтение значения датчика веса (возвращает вес в граммах)
- `calibrate_weight` - запуск процедуры обнуления датчика веса
- `staterotor` - чтение состояния 4 датчиков ротора (возвращает строку из 4 символов, где '0' - активен, '1' - неактивен)
- `waste` - чтение состояния датчика отходов (возвращает '0' - активен, '1' - неактивен)

### Диагностические команды
- `check_multi_endstop` - проверка состояния концевого выключателя Multi-двигателя
- `check_multizone_endstop` - проверка состояния концевого выключателя Multizone-двигателя
- `check_rright_endstop` - проверка состояния концевого выключателя RRight-двигателя
- `check_rleft_endstop` - проверка состояния концевого выключателя RLeft-двигателя
- `check_all_endstops` - проверка состояния всех концевых выключателей

## Формат ответов

После получения команды система немедленно отвечает подтверждением:
- `RECEIVED` - команда получена и обрабатывается

По завершении выполнения команды система отвечает одним из следующих сообщений:
- `COMPLETED` - команда успешно выполнена
- `ERR: [текст ошибки]` - ошибка выполнения с указанием причины
- Числовое значение - при запросе состояния датчиков
- Диагностическая информация - при использовании диагностических команд

## Примеры использования

```
# Отправка команды и ожидаемые ответы
> move_multi 1000
< RECEIVED
< COMPLETED

# Пример ошибки
> move_multi
< RECEIVED
< ERR: NO POSITION

# Чтение датчиков
> weight
< RECEIVED
< 512

# Обнуление датчика веса
> calibrate_weight
< RECEIVED
< Запуск процедуры обнуления датчика веса...
< Убедитесь, что на весах ничего нет
< Начинаю обнуление...
< Датчик веса успешно обнулен!
< COMPLETED

# Включение насоса
> pump_on
< RECEIVED
< COMPLETED

# Включение и выключение клапана
> kl1_on
< RECEIVED
< COMPLETED

> kl1_off
< RECEIVED
< COMPLETED

# Управление сервоприводами
> servo1 50
< RECEIVED
< COMPLETED

> servo2 75
< RECEIVED
< COMPLETED
```

## Датчик веса HX711

Для работы с датчиком веса HX711 используется неблокирующая библиотека [NBHX711](https://github.com/whandall/NBHX711), которая позволяет считывать данные с датчика без блокировки основного цикла выполнения программы. Это обеспечивает плавную работу всей системы и мгновенный отклик на команды даже во время измерения веса.

### Особенности работы с весами

- Датчик работает в неблокирующем режиме, обновляя данные в фоновом режиме
- Используется буфер из 16 последних измерений для сглаживания показаний
- Для обнуления (тарирования) датчика используйте команду `calibrate_weight`
- Для правильной работы функция `updateWeightSensor()` вызывается в каждой итерации основного цикла `loop()`

### Процесс обнуления весов

1. Убедитесь, что на весах ничего нет
2. Отправьте команду `calibrate_weight`
3. Дождитесь сообщения о начале обнуления
4. Через несколько секунд появится сообщение об успешном обнулении датчика
5. Теперь можно использовать весы для измерений (команда `weight`)

## Примечания

- Датчик веса HX711 работает в неблокирующем режиме для обеспечения отзывчивости системы
- Хоминг выполняется в течение максимум 10 секунд, после чего выдается ошибка таймаута
- После успешного хоминга двигатель отъезжает на 100 шагов от концевого выключателя
- Скорость двигателей установлена на 500 шагов/сек с ускорением 800 шагов/сек²
- Скорость хоминга составляет 300 шагов/сек
- При диагностике концевых выключателей состояние отображается как "TRIGGERED" (сработал) или "NOT TRIGGERED" (не сработал)

## Отладка и устранение неполадок

### Проблемы связи

Если плата не отвечает на команды или связь работает некорректно, проверьте следующее:

1. **Правильный формат команд**: Убедитесь, что каждая команда заканчивается символом новой строки (`\n`). Некоторые терминалы требуют ручного добавления символа новой строки.

2. **Скорость последовательного порта**: Убедитесь, что скорость последовательного порта установлена на 115200 бод.

3. **Правильный порт**: Проверьте, подключены ли вы к правильному COM-порту.

4. **Тайминг**: После подключения к Arduino подождите несколько секунд, чтобы Arduino завершила инициализацию и была готова принимать команды.

5. **Загрузите тестовый скетч**: В каталоге `src/test_serial` находится упрощенный скетч для проверки связи. Загрузите его для диагностики проблем с последовательным портом.

### Улучшенный тестовый скетч

Для диагностики проблем с последовательной связью в проекте есть специальный тестовый скетч (`src/test_serial/test_serial.ino`), который предоставляет следующие функции:

1. **Визуальная индикация запуска** - мигание светодиода при запуске
2. **Проверка связи** - команда `ping` возвращает `pong`
3. **Управление LED** - команды `on`, `off`, `blink` для проверки выходов
4. **Эхо-режим** - команда `echo <текст>` возвращает введенный текст
5. **Информация о системе** - команда `info` выводит данные о плате
6. **Периодические сообщения** - каждые 2 секунды система отправляет напоминание о готовности

Порядок использования тестового скетча:

1. Загрузите скетч `src/test_serial/test_serial.ino` на плату MKS Gen L v1
2. Откройте монитор последовательного порта со скоростью 115200 бод
3. Убедитесь, что видите начальное сообщение о запуске
4. Отправьте тестовую команду, например `ping`, для проверки связи
5. Обратите внимание на мигание встроенного светодиода на плате

### Отладочные инструменты

1. **Команда test**: Отправьте команду `test` для проверки связи. Плата должна ответить:
   ```
   RECEIVED
   Test command successful!
   COMPLETED
   ```

2. **Мониторинг инициализации**: При старте плата должна выдавать подробную информацию о процессе инициализации, включая назначение пинов. Если эти сообщения не отображаются, возможно, проблема с питанием или соединением.

3. **Светодиод на плате**: При получении и обработке команд на плате должен мигать встроенный светодиод. Если светодиод не мигает при отправке команд, это может указывать на проблемы с получением команд.

### Пошаговая диагностика проблем связи

Если плата не отвечает на отправляемые команды, выполните следующие шаги для диагностики:

1. **Проверка базовой работы платы**:
   - Загрузите простейший скетч Blink из примеров Arduino IDE
   - Убедитесь, что встроенный светодиод мигает
   - Это подтвердит, что плата работает и процесс загрузки скетчей функционирует

2. **Проверка последовательного порта**:
   - Загрузите тестовый скетч из `src/test_serial`
   - Откройте монитор порта и проверьте, отображаются ли сообщения о запуске
   - Проверьте, что при отправке команды `ping` приходит ответ `pong`

3. **Проверка основного скетча**:
   - Загрузите основной скетч из `src/main.ino`
   - Проверьте, выводятся ли сообщения о процессе инициализации
   - Отправьте простейшую команду `test` и проверьте ответ

4. **Диагностика времени отклика**:
   - Измерьте время между отправкой команды и получением ответа
   - Если ответ приходит с большой задержкой, возможно, есть проблемы с производительностью

5. **Проверка формата команд**:
   - Убедитесь, что каждая команда заканчивается переводом строки (`\n`)
   - Проверьте, не добавляет ли терминал дополнительные символы (например, `\r`)

### Возможные решения

1. **Перезагрузка платы**: Перезагрузите плату, нажав кнопку Reset.

2. **Проверка питания**: Убедитесь, что плата получает достаточно питания. Проблемы с питанием могут вызывать нестабильную работу.

3. **Перезагрузка ПК и порта**: Отключите и снова подключите USB-кабель, перезагрузите последовательный терминал.

4. **Изоляция проблемы**: Если возможно, отключите некоторые устройства (двигатели, датчики) для исключения помех или конфликтов.

5. **Проверка библиотек**: Убедитесь, что все необходимые библиотеки установлены и их версии совместимы с вашей платой.

6. **Проверка скорости порта**: Попробуйте уменьшить скорость порта до 9600 бод в тестовом скетче для проверки стабильности связи.

7. **Замена USB-кабеля**: Некоторые USB-кабели могут иметь проблемы с передачей данных, особенно длинные или недостаточно экранированные.

8. **Использование другого USB-порта**: Некоторые USB-порты на компьютере могут работать нестабильно.

Если проблема сохраняется даже при использовании тестового скетча, возможно, есть аппаратные проблемы с платой или компьютером, и может потребоваться замена оборудования или обращение к специалистам.